0. 概述
    1. Java 为 8 个基本类型提供了对应的包装类, 通过这些包装类可以把8个基本类型的值包装成对象使用;
    2. JDK1.5 提供自动装箱和自动拆箱功能, 允许把基本类型值直接赋给对应的包装类引用变量, 也允许把包装类
        对象直接赋给对应的基本类型变量
    3. final 关键字用来修饰变量, 方法和类, 系统不允许为 final 修饰的变量重新赋值, 子类不允许覆盖父类的
        final 修饰的方法, final 类不能派生子类. 即: 通过 final 关键字, 允许 Java 实现不可变类
    4. abstract 和 interface 两个关键字分别用于定义抽象和接口, 抽象类和接口都是从多个子类中抽象出来的
        共同特征, 但抽象类主要作为多个类的模版, 而接口则定义了多类应该遵守的规范
    5. enum 关键字用于创建枚举类, 枚举类是一种不能自由创建对象的类, 美剧类在定义的时已经固定下来

1. Java 8 增强的包装类
    1.1 基本数据类型的包装类
        说明:
            1. 为了解决 8 中基本数据类型的变量不能当成 Object 类型变量使用的问题, 才出现了包装类(Wrapper
                Class)的概念, 为 8 中基本类型的数据分别定义了相应的引用类型
            2. 熟记下面的对应关系, 着重记住 int---Integer 和 char---Character 这两种比较特殊的对应关系
            3. 包装类的初始值为null
            4. 基本数据类型存储在栈(stack)中，而包装类分成引用和实例，引用存储在栈内存中，而具体的实例则存
                储在堆(heap)中

        基本数据类型和引用数据类型
            <基本数据类型>       <引用数据类型>
                byte                Byte
                short               Short 
                int                 Integer
                long                Long 
                char                Character 
                float               Float 
                double              Double 
                boolean             Boolean 

    1.2 自动装箱和自动拆箱
        说明:(基本类型和包装类之间的转换自动/手动)
            1. 自动装箱(Autoboxing): 就是可以把一个基本类型变量直接赋给对应的包装类变量, 或者赋给 Object 
                变量(Object 是所有类的父类, 子类对象可以直接赋给父类变量)；装箱时调用valueOf()方法实现，
                例如：Integer.valueOf(100);
                自动装箱比如： Integer i = 100;
                手动装箱比如:  Integer i = Tnteget.valueOf(100); 
            
            2. 自动拆箱(AutoUnboxing): 把包装类对象直接赋给一个对应的基本类型变量; 拆箱时调用对应的
                XxxValue() 方法实现， 比如：intValue() 方法
                自动拆箱比如： Integer i = 100; 
                              int t1 = i;   // 自动拆箱
                手动拆箱比如： int t2 = i.intValue();
           
            3. 进行自动装箱和自动拆箱时必须注意类型匹配, 如: Integer 只能自动拆箱成 int 类型变量, 不能拆
                成别的类型; 同样, int 类型变量只能自动装箱成 Integer 对象 (例子1)
            
            4. 目的: 通过自动装箱和自动拆箱功能, 开发者可以把基本类型的变量 "近似" 地当成对象使用, 同样, 
                也可以把包装类的实例近似地当成基本类型的变量使用
            
        基本类型和字符串之间的转换:(例子2)
            基本类型转换为字符串：
                1. 通过String类的 String.valueOf(primitive) 方法 
                2. 使用包装类的 toString()方法，WrapperClass.toString() 方法
                3. 使用基本类型加上一个空字符串方法： 基本类型 + ""  
            字符串转换为基本类型：
                1. 通过 WrapperClass.parseXxx() 方法
                2. 调用包装类的 WrapperClass.valueOf()方法，会自动拆箱 
             
        例子1:
            // 自动装箱和自动拆箱
            public class AutoboxingUnboxing{
                public static void main(String[] args){
                    // 直接把一个基本类型变量赋给 Integer 对象(自动装箱)
                    Integer inObj = 5;
                    // 直接把一个 boolean 类型的变量赋给一个 Object 类型的变量(自动装箱)
                    Object boolObj = true;
                    // 直接把一个 Integer 对象赋给 int 类型的变量(自动拆箱)
                    int it = inObj;
                    System.out.println(it);  out: 5
                    if (boolObj instanceof Boolean){
                        // 先把 Object 对象强制类型转换为 Boolean 类型, 在赋给 boolean 变量 
                        boolean b = (Boolean)boolObj;
                        System.out.println(b);   // out: true
                    }
                }
            }
            程序说明:
                1. 基本类型转引用数据类型: 直接将基本类型的值赋值给引用数据类型的变量
                2. 引用数据类型转基本类型: 直接将引用类型值赋值给基本数据类型的变量

        例子2:
            // 字符串和基本类型之间的转换
            public class Primitive2String{
                public static void main(String[] args){
                    String intStr = "123";
                    // 把一个特定的字符串转换为 int 变量
                    int it1 = Integer.parseInt(intStr);
                    int it2 = Integer.valueOf(intStr);
                    System.out.println(it1);   // out: 123
                    System.out.println(it2);   // out: 123
                    String floatStr = "3.14";
                    // 把一个特定的字符串转换成 float 变量 
                    float ft1 = Float.parseFloat(floatStr);
                    float ft2 = Float.valueOf(floatStr);
                    System.out.println(ft1);   // out: 3.14
                    System.out.println(ft2);   // out: 3.14
                    // 把一个float 变量转换成 String 变量 
                    String ftStr1 = String.valueOf(3.1415926F);
                    String ftStr2 = Float.toString(3.1415926F);
                    String ftStr3 = 3.1415926F + "";
                    System.out.println(ftStr1);   // out: 3.1415925
                    System.out.println(ftStr2);   // out: 3.1415925
                    System.out.println(ftStr3);   // out: 3.1415925
                    // 把一个 double 变量转换成 String 变量 
                    String dbStr = String.valueOf(6.25789);
                    System.out.println(dbStr);   // out: 3.25789
                    // 把一个 boolean 变量转换成 String 变量
                    String boolStr = String.valueOf(true);
                    System.out.println(boolStr.toUpperCase());   // out: TRUE
                }
            }
 

    1.3 包装类和数值类型的比较
        说明:
            1. 包装类的实例可以与数值类型的值进行比较, 这种比较是直接取出包装类实例所包装的数值来进行比较,因为包
                装类的实例实际上是引用类型, 只有两个包装类引用指向同一个对象时返回true (例子1)
            2. 注意: 系统把一个 -128~127 之间的整数自动装箱成 Integer实例, 并放入了一个名为 cache 的数组中缓存
                了起来; 所以将 -128~127 之间的整数自然数自动装箱成一个 Integer 实例时, 实际上是直接指向对象的
                数组元素, 因此 -128~127 之间的同一个整数自动装箱成 Integer 实例时, 都是引用 cache 数组的同一个
                数组元素, 所以他们全部相等(例子2)
            3. Java7 为所有的包装类提供了一个静态的 compare(xxx val1, xxx val2)方法, 用来比较两个基本类值的大小,
                (两个boolean 类型的值比较的时候, true > false) (例子3)

        Java8 增强的包装类方法(例子4)
            1. static String toUnsignedString(int/long i)
                该方法将指定 int 或 long 型整数转换为无符号整数对应的字符串
            2. static String toUnsignedString(int/long i, int radix)
                该方法将指定 int 或 long 型的整数转换为指定进制的无符号整数对应的字符串
            3. static xxx parseUnsignedString(String s)
                该方法将指定字符串解析成无符号整数, 当调用类为 Integer时, xxx代表int; 当调用类是Long时, xxx代表long
            4. static xxx parseUnsignedString(String s, int radix)
                该方法将指定字符串按指定的进制解析成无符号整数, 当调用类为 Integer时, xxx代表int; 当调用类是Long时, 
                xxx代表long
            5. static int compareUnsigned(xxx x, xxx y)
                该方法将 x, y两个整数转换为无符号整数后比较大小, 当调用类为 Integer时, xxx代表int; 当调用类是Long时, 
                xxx代表long
            6. static long divideUnsigned(long divided, long divisor)
                该方法将x, y 两个整数转换为无符号整数后计算他们相除的商, 当调用类为 Integer时, xxx代表int; 当调用类 
                是Long时,xxx代表long
            7. static long remainderUnsigned(long divided, long divisor)
                该方法将x, y 两个整数转换为无符号整数后计算他们相除的余数, 当调用类为 Integer时, xxx代表int; 当调用 
                类是Long时,xxx代表long

        例子1:
            System.out.println("比较2个包装类的实例是否相等:" + (new Integer(2) == new Integer(2)));  //out:false
            Integer a = 6; 
            System.out.println("6的包装类是否大于5.0: " + (a > 5.0));  // out: true
            说明:
                1. "==" 作用于基本类型的变量:则直接比较存储的 "值" 是否相等; 
                        作用于引用数据类型的变量: 则比较的是所指向的对象的地址
                2. "equals" 不能作用于基本数据类型的变量
                        如果没有重写equals方法: 则比较的是引用类型的变量所指向的对象的地址
                        如果String, Date类对 equals 方法重写了的话,比较的是所指向的对象的内容

        例子2:
            // 通过自动装箱, 允许把基本类型的值赋给包装类实例
            Integer ina = 2;
            Integer inb = 2;
            System.out.println("两个2自动装箱后是否相等:" + (ina == inb));  // out:true
            Integer biga = 128;
            Integer binb = 128;
            System.out.println("两个128自动装箱后是否相等:" + (biga == bigb));  // out:false

        例子3:
            // java7 提供的 compare(xxx val1, xxx val2); 方法
            System.out.println(Boolean.cpmpare(ture, false));   // out: 1
            System.out.println(Boolean.cpmpare(ture, ture));    // out: 0
            System.out.println(Boolean.cpmpare(false, ture));   // out: -1
            System.out.println(Integer.compare(11, 22));   // out: -1
            System.out.println(Integer.compare(11, 2));    // out: 1

        例子4:
            // Java8 增强包装类的无符号算术运算
            public class UnsignedTest{
                public static void main(String[] args){
                    byte b = -3;
                    // 将 byte 类型的 -3 转换为无符号整数
                    System.out.println("byte类型的-3对应的无符号整数:" 
                        + Byte.toUnsignedInt(b)); // out: 253
                    // 指定使用十六进制解析无符号整数
                    int va1 = Integer.parseUnsignedInt("ab", 16);
                    System.out.println(va1);   // out: 171
                    // 将 -12转换为无符号 int 类型, 然后转换为十六进制的字符串
                    System.out.println(Integer.toUnsignedString(-12, 16)); // out: fffffff4
                    // 将两个数转换为无符号整数后相除
                    System.out.println(Integer.divideUnsigned(-2, 3));   // out: 1431655764
                    // 将两个数转换为无符号整数后相除后求余
                    System.out.println(Integer.remainderUnsigned(-2, 7));  // out: 2
                }
            }
            程序说明:
                1. 无符号整数最大的特点是最高位不再被当成符号位, 因此无符号整数不支持负数, 其最小值为 0
                2. 理解例子4的关键是先把操作数转换为无符号整数, 然后在进行计算
                3. 如: byte 类型的 -3, 其原码为:10000011(最高位的1代表负数), 其反码为:11111100, 补码
                    为: 11111101; 将该数当成无符号整数处理, 最高位的1不再代表符号位, 也就是数值位, 该
                    数对应为 253
                    

2. 处理对象
    2.1 打印对象 和 toString 方法
        说明:
            1. Java对象都是Object 类的实例, 都可直接调用该类中定义的方法, 如: 所有的Java类都具有toString()方法
            2. 所有的Java对象都可以和字符串进行连接运算, 当Java对象和字符串进行连接运算时, 系统自动调用Java对象
                的 toString()方法的返回值和字符串进行连接运算(例子1)
            3. toString() 方法是一个"自我描述"方法, 通常用于实现这样的功能: 当程序员直接打印该对象时, 系统将会
                输出该对象的 "自我描述" 信息, 用于告诉外界该对象具有的状态信息
            4. Object 类提供的 toString()方法总是返回该对象实现类的 "类名 + @ + hashCode" 值, 这个返回值并不能
                真正实现"自我描述"的功能, 但是可以通过重新Object类的toString()方法者自定义"自我描述"的功能(例子2)
            5.  重写toString()方法定义返回值格式:(例子3) 类名[field1=值1, Field2=值2,...]
        
        例子1:
            // 打印对象
            class Person{
                private String name;
                public Person(String name){
                    this.name = name;
                }
            }
            public class PrintObject{
                public static void main(String[] args) {
                    // 创建一个 Person 对象, 赋值给 p 变量
                    Person p = new Person("shuidaojinshi");
                    // 打印 P 引用的 Person 对象 
                    System.out.println(p);   // out: Person@3b192d32
                    System.out.println(p.toString());   // out: Person@3b192d32
                    String pStr = p + "";
                    System.out.println(pStr);     // out: Person@3b192d32
                    String pStr1 = p.toString() + "";
                    System.out.println(pStr1);    // out: Person@3b192d32
                    // System.out.println(p.name);  // 编译错误的原因是private修饰的只能在当前类使
                }
            }
        例子2:
            // 自定义toString()方法的返回值(通过重写Object类下的toString()方法)
            class Apple{
                private String color;
                private double weight;
                // 无参数构造器
                public Apple(){ }
                // 提供拥有参数的构造器
                public Apple(String color, double weight){
                    this.color = color;
                    this.weight = weight;
                }
                // setColor getColor方法
                public void setColor(String color){
                    this.color = color;
                }
                public String getColor(){
                    return this.color;
                }
                // serWeight getWeight 方法
                public void setWeight(double weight){
                    this.weight = weight;
                }
                public double getWeight(){
                    return this.weight;
                }
                // 重写 toString()方法, 用于实现 Apple 对象的"自我描述"
                public String toString(){
                    return "this is a apple, it's color is : " + getColor() + ", weight is: " + getWeight();   
                }
            }
            public class ToStringTest{
                public static void main(String[] args){
                    // 调用的无参构造器
                    Apple a = new Apple();
                    //  通过setter方法来赋值
                    a.setColor("RED");
                    a.setWeight(5.68);
                    System.out.println(a); // out: this is a apple, color is: RED, weight is: 5.68
                    System.out.println(a.toString()); // out: this is a apple, color is: RED, weight is: 5.68
                }
            }
        例子3:
            // 改写格式化的 Apple类的 toString()方法的返回值
            public String toString(){
                return "Apple[color = " + color + ", weight = " + weight + "]"; 
            }

    2.2 == 和 equals 方法 
        说明:
            1. == 运算符 和 equals() 方法都是用来测试两个变量是否相等的两种方法
            2. == 运算符:(例子1)
                2.1 当两个变量都是基本类型(都是数值类型)时: 则只要两个变量的 值 相等, 才返回 true
                2.2 当两个都是引用类型的变量时: 只有它们指向同一个对象时, == 判断才返回true, 
                2.3 == 运算符不可用来比较类型上没有父子关系的两个对象 
            3. equals() 方法是Object类提供的一个实例方法, 所有类都可以调用, equals()方法要求两个引用变量指向同一个对象
                才会返回true, 即Object类的equals()方法比较的结果与==运算符比较的结果完全相等
            4. String() 重写了Object类的equals()方法:String()的equals()方法判断两个字符串相等的标准是: 只要两个字符串
                包含的字符序列相同, 通过equals()比较将返回true, 否则将返回 false

        正确重新 equals() 方法的条件:
            1. 自反性: 对任意x, x.equals(x) 一定返回 true 
            2. 对称性: 对任意的 x 和 y, 如果 y.equals(x) 返回true, 则 x.equals(y) 也返回true 
            3. 传递性: 对任意的x, y, z, 如果 x.euqals(y)返回ture, y.equals(z)返回true, 则 x.equals(z) 也返回true
            4. 一致性: 对任意的x, y, 如果对象中用于等价比较傲的信息没有改变, 那么无论调用 x.equals(y)多少次, 返回的
                结果应该保持一致性, 要么一直是true, 要么一直是false 
            5. 对任意的不是null的x, x.equals(null)一定返回false

        例子1:
           // == 来判断两中类型变量是否相等
            public class EqualTest{
                public static void main(String[] args){
                    int it = 65;
                    float f1 = 65.0f;
                    // 将输出 true
                    System.out.println("65和65.0f是否相等? " + (it == f1));

                    char ch = 'A';
                    // 将输出 true， 因为 == 运算符比较基本类型时比较的时二者的值
                    System.out.println("65和'A'是否相等? " + (it == ch));

                    String str1 = new String("hello");
                    String str2 = new String("hello");
                    String str3 = str1;
                    // 将输出false
                    System.out.println("str1和str2是否相等? " + (str1 == str2));
                    // 将输出true, 因为 == 运算符比较引用类型时比较的时二者的引用地址
                    System.out.println("str1和str3是否相等? " + (str1 == str3));

                    // 将输出true， 因为 equals()方法比较引用类型比较的时二者的引用地址
                    System.out.println("str1 是否 equals str2? " + (str1.equals(str2)));
                    // 由于 java.lang.string 与 EqualTest类没有继承关系
                    // 所以下面的语句将导致编译错误
                    // System.out.println("hello" == new EqualTest());
                }
            }
            程序说明:
                1. Java程序直接使用如"Hello"这种字符串直接量(包括可以在编译时就计算出来的字符值)时，JVM将会使用
                    常量池来管理这些字符串
                2. 当使用 new String("hello"); 时，JVM会先使用常量池来管理"hello"直接量，在调用String类的构造器
                    来创建一个新的 String 对象，新创建的 String 对象被保存在堆内存中，所以，new String("hello");
                    这句代码一共产生了两个字符串对象
                3. 常量池(constant pool) 专门用于管理在编译时被确定并被保存在已编译的.class文件中的一些数据，它还
                    包括了关于类，方法， 接口中常量，还包括字符串常量。
        例子2：
            // JVM使用常量池管理字符串直接量的情形
            public class StringCompareTest{
                public static void main(String[] args) {
                    //s1直接引用常量池中的 "你好 世界！"
                    String s1 = "你好世界";
                    String s2 = "你好";
                    String s3 = "世界";

                    // s4 后面的字符串值可以直接在编译时就确定下来
                    // s4 直接引用常量池中的 "你好 世界！"
                    String s4 = "你好" + "世界";
                    
                    // s5 后面的字符串值可以直接在编译时就确定下来
                    // s5 直接引用常量池中的 "你好 世界！"
                    String s5 ="你" + "好" + "世" + "界";

                    // s6 后面的字符串不能在编译时候就确定值
                    // 所以 s6 不能引用常量池的字符串
                    String s6 = s2 + s3;

                    // 使用 new 调用构造器将会创建一个新的 String 对象
                    // s7 引用堆内存中新创建的 String 对象
                    String s7 = new String("你好 世界");

                    System.out.println(s1 == s4);   // out: true
                    System.out.println(s1 == s5);   // out: true
                    System.out.println(s1 == s6);   // out: false
                    System.out.println(s1 == s7);   // out: false
                }
            }
            程序说明:
                1. JVM常量池保证相同的字符串直接量只有一个，不会产生多个副本。例子中 s1, s4, s5所引用的字符串
                    可以在编译期就确定下来，因此他们都将引用常量池中同一个字符串的对象
                2. 使用 new String()创建的字符串对象时运行时创建出来的，它被保存在堆内存中，不会放入常量池
        例子3：
            // 重写euqals()方法
             class Person{
                private String name;
                private String idStr;
                public Person(){}
                public Person(String name, String idStr){
                    this.name = name;
                    this.idStr = idStr;
                }
                public void setName(String name){
                    this.name = name;
                }
                public String getName(){
                    return this.name;
                }
                public void setIdStr(String idStr){
                    this.idStr = idStr;
                }
                public String getIdStr(){
                    return this.idStr;
                }
                // 重写 equals()方法， 提供自定义的相等标准
                public boolean equals(Object obj){
                    // 如果两个对象为同一个对象
                    if(this == obj)
                        return true;
                    // 只有当 obj 是 Person 对象
                    // obj.getClass() == Person.class 判断obj是否是Person类的实例
                    if (obj != null && obj.getClass() == Person.class){
                        Person personObj = (Person)obj;
                        // 并且当前对象的 idStr 与 对象的 idStr 相等时才可以判断两个对象相等
                        if (this.getIdStr().equals(personObj.getIdStr())){
                            return true;
                        }
                    }
                    return false;
                }
            }
            public class OverrideEqualsRight{
                public static void main(String[] args) {
                    Person p1 = new Person("孙悟空", "123456789");
                    Person p2 = new Person("孙行者", "123456789");
                    Person p3 = new Person("孙悟饭", "1010001010");
                    // p1 和 p2 的 idStr 相等， 所以输出true
                    System.out.println("p1和p2是否相等： " + p1.equals(p2));
                    // p2 和 p3 的 idStr 不相等， 所以输出 false
                    System.out.println("p2和p3是否相等： " + p2.equals(p3));
                }
            }    
            程序说明：
                1. 用于比较的equals() 方法时可以重写的，可以加上自己需要的判断规则
                2. Person类重写了equals()方法，指定了 Person 对象和其他对象相等的标准(equals方法体代码)：另一个
                    对象必须是Person类的实例，且两个 Person 对象的 idStr 相等，即可判断两个 Person 对象相等；在
                    这种判断标准下，就是只要两个 Person 对象的身份证字符串相等，即可判断相等


3. 类成员
    3.1 理解类成员
        说明:
            1. static 关键字修饰的成员就是类成员, 包括: 类变量, 类方法, 静态初始化块, 内部类(包括接口,枚举)
            2. static 关键字不能修饰构造器, static 修饰的类成员属于整个类, 不属于单个实例
            3. static 关键字规则: 类成员(包括方法, 初始化块, 内部类和枚举类)不能访问实例成员(包括成员变量, 方法,
                初始化块, 内部类和枚举类). 因为类成员是属于类的, 类成员的作用域比实例成员的作用域更大, 完全可能出
                现类成员已经初始化完成, 但实例成员还不曾初始化的情况, 如果允许类成员访问实例成员将会引起大量的错误

        类变量:
            1. 类变量属于整个类, 当系统第一次准备使用该类的时, 系统会为该类变量分配内存空间, 类变量开始生效,直到该
                类被卸载, 该类变量占用的内存空间才会被系统的垃圾回收机制回收. 类变量的生存范围几乎是等同于该类的生
                存范围
            2. 类变量可以通过 类.类变量 或者 类的对象.类变量 的形式来访问. 对象不拥有对应类的类变量, 当通过对象来
                访问类变量只是一种假象, 实际上依然访问的是该类的类变量. 所以可以理解为: 当通过对象来访问类变量时,
                系统会在底层转换为通过该类来访问类变量
            3. 同一个类的所有对象访问类变量时, 实际上访问的都是该类所持有的变量, 即同一个类的所有实例的类变量共享同
                一块内存区

        类方法:
            1. 类方法也是属于类, 可通过 类.类方法 或 实例.类方法 来调用. 
            2. 与类变量一样, 使用对象来调用类方法, 其效果也与采用类来调用方法完全一样
            3. 当使用实例来访问类成员时, 实际上依然是委托该类来访问类成员, 即使某个实例为null, 它也可以访问它所属类
                的类成员(例子1) 
            4. 3 的补充: 如果一个null对象访问实例成员(包括实例方法和实例变量), 将引发 NullPointerExamption 异常,
                因为null表明这个实例根本不存在, 所以它的实例变量和实例方法自然也就不存在

        静态初化块:
            1. 静态初始化块用于执行类初始化动作, 在类的初始化阶段, 系统会调用该类的静态初始化块来对类进行初始化. 一旦
                该类的初始化结束后, 静态初始化块将永远不会获得执行的机会（静态初始化块就是 static 修饰的初始化块(如：
                static{代码})，只在第一次加载类的时候只执行一次）
            2. 静态初始化块 非静态初始化块 构造函数等执行顺序
                2.1 静态初始化块的优先级最高，也就是最先执行，并且仅在类第一次被加载时执行
                2.1 非静态初始化块和构造函数后执行，并且在每次生成对象时执行一次；
                2.3 非静态初始化块的代码会在类构造函数之前执行。因此若要使用，应当养成把初始化块写在构造函数之前的习惯，
                    便于调试；
                2.4 静态初始化块既可以用于初始化静态成员变量，也可以执行初始化代码；
                2.5 非静态初始化块可以针对多个重载构造函数进行代码复用。
        例子1:
            public class NullAccessStatic{
                private static void test(){
                    System.out.println("static修饰的类方法!");
                }
                public static void main(String[] args) {
                    // 定义一个 NullAccessStatic 变量, 其值为 null
                    NullAccessStatic nas = null;
                    // 使用 null 对象调用所属类的静态方法
                    nas.test();  // out: "static修饰的类方法!"
                }
            }

    3.2 单例(Singleton)类
        说明:
            1. 如果一个类始终只能创建一个实例, 则这个类被称为单例类(例子1)  
            2. 通过将构造器使用 private 修饰, 从而把该类的所有构造器隐藏起来
            3. 一旦把该类的构造器隐藏起来, 就需要提供一个 public 方法作为该类的访问点, 用于创建该类的对象, 且该方法
                必须使用 static 修饰, (因为调用该方法之前还不存在对象, 因此调用该方法的不可能是对象, 只能是类)
            4. 该类还必须缓存已经创建的对象, 否则该类无法知道是否曾经创建过对象, 也就无法保证只创建一个对象. 为此该类
                需要使用一个成员变量来保存曾经创建的对象, 因为该成员变量需要被上面的静态方法访问, 所以成员变量必须使
                用 static 修饰
        例子1:
            class Singleton{
                // 使用一个类变量来缓存曾经创建的实例
                private static Singleton instance;
                // 对构造器使用 private 修饰, 隐藏该构造器
                private Singleton(){}
                // 提供一个静态方法, 用于返回 Singleton 实例
                // 该方法可以加入自定义控制, 保证只产生一个 Singleton 对象
                public static Singleton getInstance(){
                    // 如果 instance 为 null, 则表明还不曾创建 Singleton 对象
                    // 如果 instance 不为 null, 则表明已经创建了 Singleton 对象
                    // 将不会创建新的实例
                    if (instance == null){
                        // 创建一个 Singleton 对象, 并将其缓存
                        instance = new Singleton();
                    }
                    return instance;
                }
            }
            public class SingletonTest{
                public static void main(String[] args) {
                    // 创建 Singleton 对象不能通过构造器
                    // 只能通过 getInstance 方法来得到实例
                    Singleton s1 = Singleton.getInstance();
                    Singleton s2 = Singleton.getInstance();
                    System.out.println(s1 == s2);  // out: true
                }
            }
            程序说明：
                1. 上面的例子中通过 private 修饰构造器， 从而隐藏了该类创建对象的渠道
                2. 通过 public 修饰的 getInstance 方法提供的自定义控制(这也是封装的优势：不允许自由访问类的成员变量和
                    实现细节，而是通过方法来控制合适的暴露)，从而保证 Singleton 类只能产生一个实例。所以在 Singleton 
                    类的 main() 方法中，看到两次产生的 Singleton 对象实际上是同一个对象
 

4. final 修饰符
    4.1 final 成员变量
        说明：
            1. final 关键字可用于修饰类，变量和方法，用于表示修饰的类，方法和变量不可改变
            2. final 修饰变量时，表示该变量一旦获得了初始值就不可改变(不能被重新赋值)，final 可修饰成员变量(类变量和实例变量)
                也可修饰局部变量和形参
            3. final 修饰的成员变量必须由程序员显式的指定初始值（例子1）
            4. 类变量：必须在静态初始化块中指定初始值或者在声明该类变量时指定初始值，而且只能在这两个地方的其中之一指定
            5. 实例变量：必须在非静态初始化块，声明该实例变量或构造器中指定初始值， 而且只能在这三个地方的其中之一指定
            6. 实例变量不能在静态初始化块中指定初始值，因为静态初始化块时静态成员，不可访问实例变量--非静态成员
            7. 类变量也不能在普通初始化块中指定初始值，因为类变量在类初始化阶段已经被初始化了， 普通初始化块不能再对其重新赋值
            8. 如果在构造器或初始化块章对 final 成员变量进行初始化，那么在初始化之前不能访问成员变量的值， 否则报错（例子2）
        例子1： 
            // final 修饰成员变量的效果
            public class FinalVariableTest{
                // 定义成员变量时指定默认值，合法
                final int a = 6;
                // 下面的变量将在构造器或者初始化块中分配初始值
                final String str;
                final int c;
                final static double d;
                // 既没有指定默认值，有没有在初始化块或构造器中指定初始值
                // 下面定义的 ch 实例变量不合法
                // final char ch;
                // 初始化块， 可对没有指定默认值的实例变量指定初始值
                {
                    // 在初始化块中为实例变量指定初始值， 合法
                    str = "hello";
                    // 定义a重新赋值， 因此下面的语句非法
                    // a = 9;
                    System.out.println("普通初始化块");
                }
                // 静态初始化块中为类变量指定初始值， 合法
                static {
                    d = 5.6;
                    System.out.println("静态初始化块");
                }
                // 构造器中既可以对没有指定默认值， 有没有在初始化块中指定默认值的实例变量指定初始值
                public FinalVariableTest(){
                    // 如果在初始化块中已经为 str 指定了初始值
                    // 那么在构造器中不能对 final 变量重新赋值，下面的赋值语句非法
                    // str = "java";
                    c = 5;
                    System.out.println("构造器");
                }
                public static void main(String[] args) {
                    FinalVariableTest ft = new FinalVariableTest();
                    System.out.println(ft.a);
                    System.out.println(ft.c);
                    //The static field FinalVariableTest.d should be accessed in a static way
                    System.out.println(FinalVariableTest.d);
                }
            }
        例子2： 
            // 在普通初始化块中进行初始化之前访问 final 修饰的实例变量的值，报错
            public class FinalErrorTest{
                // 定义一个 final 修饰的实例变量, 定义时未指定值
                // 系统不会为 final 修饰的成员变量进行默认的初始化
                final int age;
                // 普通初始化块
                {
                    // age 没有初始化， 所以此处访问age的值报错
                    // The blank final field age may not have been initialized
                    // System.out.println(age);
                    age = 6;
                    System.out.println(age);
                }
                public static void main(String[] args){
                    new FinalErrorTest();
                }
            }

    4.2 final 局部变量
        说明：
            1. 系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化
            2. final 修饰的局部变量，既可在定义时指定默认值(定义时指定，后面的代码中不能再赋值)，也可不指定默认值，在后面的代码中
                对该 final 变量赋初始值，但只能一次， 不可重复。
            3. final 修饰形参时，因为形参再调用该方法时，由系统根据传入的参数来完成初始化，因此使用 final 修饰的形参不能被赋值

        例子： 
            public class FinalLocalVariableTest{
                public void test(final int a){
                    // 不能对 final 修饰的形参赋值，下面的语句非法
                    // a = 5;
                    System.out.println("不能对 final 修饰的形参赋值, 需由调用时传入参数完成初始化！" + a);
                }      
                public static void main(String[] args) {
                    // 定义 final 局部变量时指定默认值，则 str 变量无法重新赋值
                    final String str  = "Hello";
                    // 下面的语句非法
                    // str = "java";
                    // 定义局部变量时没有指定默认值，则 d 变量可被赋值一次（仅一次）
                    final double d;
                    // 第一次赋值
                    d = 5.6;
                    // 对 final 修饰的局部变量第二次赋值，下面语句非法
                    // d = 3.4;
                    System.out.println(str + " " + d);

                    FinalLocalVariableTest fl = new FinalLocalVariableTest();
                    fl.test(100);
                    fl.test(250);
                }        
            }

    4.3 final 修饰基本类型变量和引用类型变量的区别
        说明：
            1. 使用 final 修饰基本类型变量时， 不能对基本类型变量重新赋值，因此基本类型变量不能被改变
            2. 使用 final 修饰引用类型，因为引用类型保存的仅仅是一个引用，final 只保证这个引用类型变量所引用的地址不会改变，即一直
                引用同一个对象，但这个对象完全可能发生改变
        
        例子： 
            import java.util.Arrays;

            class PersonFinal {
                private int age;
                public PersonFinal(){}
                // 有参数的构造器
                public PersonFinal(int age){
                    this.age = age;
                }
                // setAge 和 getAge 方法
                public void setAge(int age){
                    this.age = age;
                }
                public int getAge(){
                    return this.age;
                }
            }
            public class FinalReferenceTest{
                public static void main(String[] args) {
                    // final 修饰数组变量，iArr 是一个引用变量
                    final int[] iArr = {5, 6, 9, 12, 2, 55, -1};
                    System.out.println(Arrays.toString(iArr));   // out: [5, 6, 9, 12, 2, 55, -1]
                    // 对数组元素进行排序， 合法
                    Arrays.sort(iArr);
                    System.out.println(Arrays.toString(iArr));   // out: [-1, 2, 5, 6, 9, 12, 55]
                    // 对数组元素赋值，合法
                    iArr[2] = -8;
                    System.out.println(Arrays.toString(iArr));   // out: [-1, 2, -8, 6, 9, 12, 55]
                    // 下面语句对 iArr 重新赋值，非法
                    // iArr = null;
                    // final 修饰 PersonFinal 变量， p 是一个引用变量
                    final PersonFinal p = new PersonFinal(45);
                    // 改变 PersonFinal 对象的 age 实例变量，合法
                    p.setAge(23);
                    System.out.println(p.getAge());   // out: 23
                    // 下面的语句对 p 重新赋值，非法
                    // p = null;
                }
            }
            程序说明：
                1. 使用 final 修饰的引用类型变量不能被重新赋值，但可以改变引用类型变量所引用对象的内容。 例如上面 iArr 变量所引用的数组
                    对象， final 修饰后的 iArr 变量不能被重新赋值，但是 iArr 所引用数组的数组元素可以改变。
                2. p 变量也使用 final 修饰，表明 p 变量不能被重新赋值，但 p 变量所引用的 PersonFinal 对象的成员变量的值可以被改变


    4.4 可执行 "宏替换" 的 final 变量 
        说明：
            1. 对于一个final 变量来说，不管它是类变量，实例变量，还是局部变量，只要该变量满足下面三个条件，那么这个 final 变量就不再是一个
                变量，而是相当于一个直接量（例子1）
                1.1 使用 final 修饰符修饰
                1.2 在定义该 final 变量时指定了初始值
                1.3 该初始值可以在编译时就被确定下来
            2. final修饰符的一个重要用途就是定义"宏变量"。当定义 final 变量时就为该变量指定了初始值，而且该初始值可以在编译时就确定下来，那么
                这个 final 变量本质上就是一个 "宏变量"，编译器会把程序中所有用到该变量的地方直接替换成该变量的值
            3. 对于 final 实例变量而言，只有定义该变量时指定了初始值才会有 "宏变量" 的效果
            4. Java会使用常量池来管理曾经用到过的字符串直接量，例如执行：String a = "Java"; 语句之后，常量池中就会缓存一个字符串"Java"；如果
                程序再次执行String b = "Java"; 系统就会让 b 直接指向常量池中的 "Java" 字符串， 因此 a == b 将会返回 True (例子2)
        例子1： 
            // 满足说明1的final修饰的变量相当于一个直接量
            public class FinalLocalTest{
                public static void mian(String[] args){
                    // 定义一个普通的局部变量
                    final int a = 5;
                    System.out.println(a);
                }
            }
            程序说明：
                1. 对于上面的程序，变量 a 其实根本不存在，当程序执行System.out.println(a);代码时，实际转换为执行System.out.println(a5;
        
        例子2：
            public class FinalABTest{
                public static void main(String[] args){
                    final String a = "Java";
                    final String b = "Java";
                    System.out.println("a == b :" + (a == b));   // out: a == b :true
                    System.out.println("a.equals(b): " + a.equals(b));   // out: a.equals(b): true
                }
            }
        例子3：
            public class StringJoinTest{
                public static void main(String[] args) {
                    String s1 = "学 Java";
                    // s2变量引用的字符串可以在编译时就确定下来
                    // 因此 s2 直接引用常量池已有的 "学 Java" 字符串
                    String s2 = "学 " + "Java";
                    System.out.println("s1 == s2: " + (s1 == s2));  // out: s1 == s2: true
                    // 定义两个字符串直接量
                    String str1 = "学 ";
                    String str2 = "Java";
                    String s3 = str1 + str2;
                    System.out.println("s1 == s3: " + (s1 == s3));   // out: s1 == s3: false
                }
            }
            程序说明：
                1. 对于 s1 和 s2 编译器在编译时就可以确定他们的值，所以系统会让 s2 直接指向常量池中缓存的字符串
                2. 而 s3 的值是由 str1 和 str2 进行连接运算后得到的，由于 str1 和 str2 是普通变量，编译器不会执行 "宏替换"，所以在
                    编译时 s3 的值时无法确定的，也就无法让 s3 指向常量池中缓存的字符串
                3. 让 s1 == s3 为 true 很简单，只要使用 final 修饰 str1 和 str2 两个变量就可以执行 "宏替换"，从而在编译时就确定s3
                    的值，进而让 s3 也指向常量池中缓存的 字符串

    4.5 final 方法
        说明：
            1. final 修饰的方法不可被重写，如：Object类里的 getClass()方法，因为Java不希望任何类重写这个方法，所以使用 final 修饰，
                从而将这个方法密封起来（例子1）
            2. 对于一个 private 修饰的方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法，
            3. rewiew: 如果子类中定义了一个与父类 private 方法由相同方法名，相同形参列表，相同返回值类型的方法，也不是重写父类的 private                
                方法，而是子类重新定义了一个新方法。因此：即使使用 final 修饰一个 private 访问权限的方法，依然可以在其子类中定义与该方法
                具有相同方法名，相同形参列表，相同返回值类型的方法（例子2）
            4. final 修饰的方法仅仅是不能被重写，并不是不能被重载（例子3）
        
        例子1：
            public class FinalMethodTest{
                public final void test(){
                    System.out.println("final 修饰的 Public 访问权限的 test() 方法");
                }
            }
            class sub extends FinalMethodTest{
                // 下面方法定义将出现编译错误，不能重写父类 final 方法
                public void test(){}
            }
        例子2： 
            // 子类定义了和父类(被 private 和final 修饰的) 相同方法名，相同形参列表，相同返回值类型的方法，但不是重写父类方法，是子类重新定义
            public class PrivateFinalMethodTest{
                private final void test(){}
            }
            class sub extends PrivateFinalMethodTest{
                // 下面的方法定义不会出现问题
                public void test(){}
            }
        例子3： 
            public class FinalOverload{
                // final 修饰的方法只是不能被重写，完全可以被重载
                public final void test(){}
                public final void test(String args){}
            }

    4.6 final 类
        说明：
            1. final 修饰的类不可以有子类，如java.lang.Math 类就是一个 final 类，它不可以有子类
            2. 也就是说 final 修饰的类不可以被继承
        例子： 
            public final class FinalClass{}
            // 下面定义的类继承FinalClass类将出现编译错误
            // class Sub entends FinalClass{}