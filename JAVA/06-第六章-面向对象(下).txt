0. 概述
    1. Java 为 8 个基本类型提供了对应的包装类, 通过这些包装类可以把8个基本类型的值包装成对象使用;
    2. JDK1.5 提供自动装箱和自动拆箱功能, 允许把基本类型值直接赋给对应的包装类引用变量, 也允许把包装类
        对象直接赋给对应的基本类型变量
    3. final 关键字用来修饰变量, 方法和类, 系统不允许为 final 修饰的变量重新赋值, 子类不允许覆盖父类的
        final 修饰的方法, final 类不能派生子类. 即: 通过 final 关键字, 允许 Java 实现不可变类
    4. abstract 和 interface 两个关键字分别用于定义抽象和接口, 抽象类和接口都是从多个子类中抽象出来的
        共同特征, 但抽象类主要作为多个类的模版, 而接口则定义了多类应该遵守的规范
    5. enum 关键字用于创建枚举类, 枚举类是一种不能自由创建对象的类, 美剧类在定义的时已经固定下来

1. Java 8 增强的包装类
    1.1 基本数据类型的包装类
        说明:
            1. 为了解决 8 中基本数据类型的变量不能当成 Object 类型变量使用的问题, 才出现了包装类(Wrapper
                Class)的概念, 为 8 中基本类型的数据分别定义了相应的引用类型
            2. 熟记下面的对应关系, 着重记住 int---Integer 和 char---Character 这两种比较特殊的对应关系
            3. 包装类的初始值为null
            4. 基本数据类型存储在栈(stack)中，而包装类分成引用和实例，引用存储在栈内存中，而具体的实例则存
                储在堆(heap)中

        基本数据类型和引用数据类型
            <基本数据类型>       <引用数据类型>
                byte                Byte
                short               Short 
                int                 Integer
                long                Long 
                char                Character 
                float               Float 
                double              Double 
                boolean             Boolean 

    1.2 自动装箱和自动拆箱
        说明:(基本类型和包装类之间的转换自动/手动)
            1. 自动装箱(Autoboxing): 就是可以把一个基本类型变量直接赋给对应的包装类变量, 或者赋给 Object 
                变量(Object 是所有类的父类, 子类对象可以直接赋给父类变量)；装箱时调用valueOf()方法实现，
                例如：Integer.valueOf(100);
                自动装箱比如： Integer i = 100;
                手动装箱比如:  Integer i = Integer.valueOf(100); 
            
            2. 自动拆箱(AutoUnboxing): 把包装类对象直接赋给一个对应的基本类型变量; 拆箱时调用对应的
                XxxValue() 方法实现， 比如：intValue() 方法
                自动拆箱比如： Integer i = 100; 
                              int t1 = i;   // 自动拆箱
                手动拆箱比如： int t2 = i.intValue();
           
            3. 进行自动装箱和自动拆箱时必须注意类型匹配, 如: Integer 只能自动拆箱成 int 类型变量, 不能拆
                成别的类型; 同样, int 类型变量只能自动装箱成 Integer 对象 (例子1)
            
            4. 目的: 通过自动装箱和自动拆箱功能, 开发者可以把基本类型的变量 "近似" 地当成对象使用, 同样, 
                也可以把包装类的实例近似地当成基本类型的变量使用
            
        基本类型和字符串之间的转换:(例子2)
            基本类型转换为字符串：
                1. 通过String类的 String.valueOf(primitive) 方法 
                2. 使用包装类的 toString()方法，WrapperClass.toString() 方法
                3. 使用基本类型加上一个空字符串方法： 基本类型 + ""  
            字符串转换为基本类型：
                1. 通过 WrapperClass.parseXxx() 方法
                2. 调用包装类的 WrapperClass.valueOf()方法，会自动拆箱 
             
        例子1:
            // 自动装箱和自动拆箱
            public class AutoboxingUnboxing{
                public static void main(String[] args){
                    // 直接把一个基本类型变量赋给 Integer 对象(自动装箱)
                    Integer inObj = 5;
                    // 直接把一个 boolean 类型的变量赋给一个 Object 类型的变量(自动装箱)
                    Object boolObj = true;
                    // 直接把一个 Integer 对象赋给 int 类型的变量(自动拆箱)
                    int it = inObj;
                    System.out.println(it);  out: 5
                    // instanceof 方法用于测试左边的对象是否是它右边类的实例, 返回的是 boolean 数据类型
                    if (boolObj instanceof Boolean){
                        // 先把 Object 对象强制类型转换为 Boolean 类型, 在赋给 boolean 变量 
                        boolean b = (Boolean)boolObj;
                        System.out.println(b);   // out: true
                    }
                }
            }
            程序说明:
                1. 基本类型转引用数据类型: 直接将基本类型的值赋值给引用数据类型的变量
                2. 引用数据类型转基本类型: 直接将引用类型值赋值给基本数据类型的变量

        例子2:
            // 字符串和基本类型之间的转换
            public class Primitive2String{
                public static void main(String[] args){
                    String intStr = "123";
                    // 把一个特定的字符串转换为 int 变量 (2种方法)
                    int it1 = Integer.parseInt(intStr);
                    int it2 = Integer.valueOf(intStr);
                    System.out.println(it1);   // out: 123
                    System.out.println(it2);   // out: 123
                    String floatStr = "3.14";
                    // 把一个特定的字符串转换成 float 变量  (2种方法)
                    float ft1 = Float.parseFloat(floatStr);
                    float ft2 = Float.valueOf(floatStr);
                    System.out.println(ft1);   // out: 3.14
                    System.out.println(ft2);   // out: 3.14
                    // 把一个float 变量转换成 String 变量 (3种方法)
                    String ftStr1 = String.valueOf(3.1415926F);
                    String ftStr2 = Float.toString(3.1415926F);
                    String ftStr3 = 3.1415926F + "";
                    System.out.println(ftStr1);   // out: 3.1415925
                    System.out.println(ftStr2);   // out: 3.1415925
                    System.out.println(ftStr3);   // out: 3.1415925
                    // 把一个 double 变量转换成 String 变量 (3种方法)
                    String dbStr1 = String.valueOf(6.25789);
                    String dbStr2 = Double.toString(6.257899);
                    String dbStr3 = 6.2578899 + "";
                    System.out.println(dbStr1);   // out: 6.25789
                    System.out.println(dbStr2);   // out: 6.257899
                    System.out.println(dbStr3);   // out: 6.2578899
                    // 把一个 boolean 变量转换成 String 变量 (3种方法)
                    String boolStr1 = String.valueOf(true);
                    String boolStr2 = Boolean.toString(false);
                    String boolStr3 = true + "";
                    System.out.println(boolStr1.toUpperCase());   // out: TRUE
                    System.out.println(boolStr2.toUpperCase());   // out: FALSE
                    System.out.println(boolStr3.toUpperCase());   // out: TRUE
                }
            }
 

    1.3 包装类和数值类型的比较
        说明:
            1. 包装类的实例可以与数值类型的值进行比较, 这种比较是直接取出包装类实例所包装的数值来进行比较,因为包
                装类的实例实际上是引用类型, 只有两个包装类引用指向同一个对象时返回true (例子1)
            2. 注意: 系统把一个 -128~127 之间的整数自动装箱成 Integer实例, 并放入了一个名为 cache 的数组中缓存
                了起来; 所以将 -128~127 之间的整数自然数自动装箱成一个 Integer 实例时, 实际上是直接指向对象的
                数组元素, 因此 -128~127 之间的同一个整数自动装箱成 Integer 实例时, 都是引用 cache 数组的同一个
                数组元素, 所以他们全部相等(例子2)
            3. Java7 为所有的包装类提供了一个静态的 compare(xxx val1, xxx val2)方法, 用来比较两个基本类值的大小,
                (两个boolean 类型的值比较的时候, true > false) (例子3)

        Java8 增强的包装类方法(例子4)
            1. static String toUnsignedString(int/long i)
                该方法将指定 int 或 long 型整数转换为无符号整数对应的字符串
            2. static String toUnsignedString(int/long i, int radix)
                该方法将指定 int 或 long 型的整数转换为指定进制的无符号整数对应的字符串
            3. static xxx parseUnsignedString(String s)
                该方法将指定字符串解析成无符号整数, 当调用类为 Integer时, xxx代表int; 当调用类是Long时, xxx代表long
            4. static xxx parseUnsignedString(String s, int radix)
                该方法将指定字符串按指定的进制解析成无符号整数, 当调用类为 Integer时, xxx代表int; 当调用类是Long时, 
                xxx代表long
            5. static int compareUnsigned(xxx x, xxx y)
                该方法将 x, y两个整数转换为无符号整数后比较大小, 当调用类为 Integer时, xxx代表int; 当调用类是Long时, 
                xxx代表long
            6. static long divideUnsigned(long divided, long divisor)
                该方法将x, y 两个整数转换为无符号整数后计算他们相除的商, 当调用类为 Integer时, xxx代表int; 当调用类 
                是Long时,xxx代表long
            7. static long remainderUnsigned(long divided, long divisor)
                该方法将x, y 两个整数转换为无符号整数后计算他们相除的余数, 当调用类为 Integer时, xxx代表int; 当调用 
                类是Long时,xxx代表long

        例子1:
            System.out.println("比较2个包装类的实例是否相等:" + (new Integer(2) == new Integer(2)));  //out:false
            Integer a = 6; 
            System.out.println("6的包装类是否大于5.0: " + (a > 5.0));  // out: true
            说明:
                1. "==" 作用于基本类型的变量:则直接比较存储的 "值" 是否相等; 
                        作用于引用数据类型的变量: 则比较的是所指向的对象的地址
                2. "equals" 不能作用于基本数据类型的变量
                        如果没有重写equals方法: 则比较的是引用类型的变量所指向的对象的地址
                        如果String, Date类对 equals 方法重写了的话,比较的是所指向的对象的内容

        例子2:
            // 通过自动装箱, 允许把基本类型的值赋给包装类实例
            Integer ina = 2;
            Integer inb = 2;
            System.out.println("两个2自动装箱后是否相等:" + (ina == inb));  // out:true
            Integer biga = 128;
            Integer binb = 128;
            System.out.println("两个128自动装箱后是否相等:" + (biga == bigb));  // out:false

        例子3:
            // java7 提供的 compare(xxx val1, xxx val2); 方法
            System.out.println(Boolean.cpmpare(ture, false));   // out: 1
            System.out.println(Boolean.cpmpare(ture, ture));    // out: 0
            System.out.println(Boolean.cpmpare(false, ture));   // out: -1
            System.out.println(Integer.compare(11, 22));   // out: -1
            System.out.println(Integer.compare(11, 2));    // out: 1

        例子4:
            // Java8 增强包装类的无符号算术运算
            public class UnsignedTest{
                public static void main(String[] args){
                    byte b = -3;
                    // 将 byte 类型的 -3 转换为无符号整数
                    System.out.println("byte类型的-3对应的无符号整数:" 
                        + Byte.toUnsignedInt(b)); // out: 253
                    // 指定使用十六进制解析无符号整数
                    int va1 = Integer.parseUnsignedInt("ab", 16);
                    System.out.println(va1);   // out: 171
                    // 将 -12转换为无符号 int 类型, 然后转换为十六进制的字符串
                    System.out.println(Integer.toUnsignedString(-12, 16)); // out: fffffff4
                    // 将两个数转换为无符号整数后相除
                    System.out.println(Integer.divideUnsigned(-2, 3));   // out: 1431655764
                    // 将两个数转换为无符号整数后相除后求余
                    System.out.println(Integer.remainderUnsigned(-2, 7));  // out: 2
                }
            }
            程序说明:
                1. 无符号整数最大的特点是最高位不再被当成符号位, 因此无符号整数不支持负数, 其最小值为 0
                2. 理解例子4的关键是先把操作数转换为无符号整数, 然后在进行计算
                3. 如: byte 类型的 -3, 其原码为:10000011(最高位的1代表负数), 其反码为:11111100, 补码
                    为: 11111101; 将该数当成无符号整数处理, 最高位的1不再代表符号位, 也就是数值位, 该
                    数对应为 253
                    

2. 处理对象
    2.1 打印对象 和 toString 方法
        说明:
            1. Java对象都是Object 类的实例, 都可直接调用该类中定义的方法, 如: 所有的Java类都具有toString()方法
            2. 所有的Java对象都可以和字符串进行连接运算, 当Java对象和字符串进行连接运算时, 系统自动调用Java对象
                的 toString()方法的返回值和字符串进行连接运算(例子1)
            3. toString() 方法是一个"自我描述"方法, 通常用于实现这样的功能: 当程序员直接打印该对象时, 系统将会
                输出该对象的 "自我描述" 信息, 用于告诉外界该对象具有的状态信息
            4. Object 类提供的 toString()方法总是返回该对象实现类的 "类名 + @ + hashCode" 值, 这个返回值并不能
                真正实现"自我描述"的功能, 但是可以通过重写Object类的toString()方法来自定义"自我描述"的功能(例子2)
            5.  重写toString()方法定义返回值格式:(例子3) 类名[field1=值1, Field2=值2,...]
        
        例子1:
            // 打印对象
            class Person{
                private String name;
                public Person(String name){
                    this.name = name;
                }
            }
            public class PrintObject{
                public static void main(String[] args) {
                    // 创建一个 Person 对象, 赋值给 p 变量
                    Person p = new Person("shuidaojinshi");
                    // 打印 P 引用的 Person 对象 
                    System.out.println(p);   // out: Person@3b192d32
                    System.out.println(p.toString());   // out: Person@3b192d32
                    String pStr = p + "";
                    System.out.println(pStr);     // out: Person@3b192d32
                    String pStr1 = p.toString() + "";
                    System.out.println(pStr1);    // out: Person@3b192d32
                    // System.out.println(p.name);  // 编译错误的原因是private修饰的只能在当前类使
                }
            }
        例子2:
            // 自定义toString()方法的返回值(通过重写Object类下的toString()方法)
            class Apple{
                private String color;
                private double weight;
                // 无参数构造器
                public Apple(){ }
                // 提供拥有参数的构造器
                public Apple(String color, double weight){
                    this.color = color;
                    this.weight = weight;
                }
                // setColor getColor方法
                public void setColor(String color){
                    this.color = color;
                }
                public String getColor(){
                    return this.color;
                }
                // serWeight getWeight 方法
                public void setWeight(double weight){
                    this.weight = weight;
                }
                public double getWeight(){
                    return this.weight;
                }
                // 重写 toString()方法, 用于实现 Apple 对象的"自我描述"
                public String toString(){
                    return "this is a apple, it's color is : " + getColor() + ", weight is: " + getWeight();   
                }
            }
            public class ToStringTest{
                public static void main(String[] args){
                    // 调用的无参构造器
                    Apple a = new Apple();
                    //  通过setter方法来赋值
                    a.setColor("RED");
                    a.setWeight(5.68);
                    System.out.println(a); // out: this is a apple, color is: RED, weight is: 5.68
                    System.out.println(a.toString()); // out: this is a apple, color is: RED, weight is: 5.68
                }
            }
        例子3:
            // 改写格式化的 Apple类的 toString()方法的返回值
            public String toString(){
                return "Apple[color = " + color + ", weight = " + weight + "]"; 
            }

    2.2 == 和 equals 方法 
        说明:
            1. == 运算符 和 equals() 方法都是用来测试两个变量是否相等的两种方法
            2. == 运算符:(例子1)
                2.1 当两个变量都是基本类型(都是数值类型)时: 则只要两个变量的 值 相等, 才返回 true
                2.2 当两个都是引用类型的变量时: 只有它们指向同一个对象时, == 判断才返回true, 
                2.3 == 运算符不可用来比较类型上没有父子关系的两个对象 
            3. equals() 方法是Object类提供的一个实例方法, 所有类都可以调用, equals()方法要求两个引用变量指向同一个对象
                才会返回true, 即Object类的equals()方法比较的结果与==运算符比较的结果完全相等
            4. String() 重写了Object类的equals()方法:String()的equals()方法判断两个字符串相等的标准是: 只要两个字符串
                包含的字符序列相同, 通过equals()比较将返回true, 否则将返回 false

        正确重新 equals() 方法的条件:
            1. 自反性: 对任意x, x.equals(x) 一定返回 true 
            2. 对称性: 对任意的 x 和 y, 如果 y.equals(x) 返回true, 则 x.equals(y) 也返回true 
            3. 传递性: 对任意的x, y, z, 如果 x.euqals(y)返回ture, y.equals(z)返回true, 则 x.equals(z) 也返回true
            4. 一致性: 对任意的x, y, 如果对象中用于等价比较傲的信息没有改变, 那么无论调用 x.equals(y)多少次, 返回的
                结果应该保持一致性, 要么一直是true, 要么一直是false 
            5. 对任意的不是null的x, x.equals(null)一定返回false

        例子1:
           // == 来判断两中类型变量是否相等
            public class EqualTest{
                public static void main(String[] args){
                    int it = 65;
                    float f1 = 65.0f;
                    // 将输出 true
                    System.out.println("65和65.0f是否相等? " + (it == f1));  // out: 65和65.0f是否相等? true

                    char ch = 'A';
                    // 将输出 true， 因为 == 运算符比较基本类型时比较的时二者的值
                    System.out.println("65和'A'是否相等? " + (it == ch));  // out: 65和'A'是否相等? true

                    String str1 = new String("hello");
                    String str2 = new String("hello");
                    String str3 = str1;
                    // 将输出false
                    System.out.println("str1和str2是否相等? " + (str1 == str2));  // out: str1和str2是否相等? false
                    // 将输出true, 因为 == 运算符比较引用类型时比较的时二者的引用地址
                    System.out.println("str1和str3是否相等? " + (str1 == str3));  // out: str1和str3是否相等? true

                    // 将输出true， 因为 equals()方法比较引用类型比较的时二者的引用地址
                    System.out.println("str1 是否 equals str2? " + (str1.equals(str2)));  // out: str1 是否 equals str2? true
                    // 由于 java.lang.string 与 EqualTest类没有继承关系
                    // 所以下面的语句将导致编译错误
                    // System.out.println("hello" == new EqualTest());
                }
            }
            程序说明:
                1. Java程序直接使用如"Hello"这种字符串直接量(包括可以在编译时就计算出来的字符值)时，JVM将会使用
                    常量池来管理这些字符串
                2. 当使用 new String("hello"); 时，JVM会先使用常量池来管理"hello"直接量，在调用String类的构造器
                    来创建一个新的 String 对象，新创建的 String 对象被保存在堆内存中，所以，new String("hello");
                    这句代码一共产生了两个字符串对象
                3. 常量池(constant pool) 专门用于管理在编译时被确定并被保存在已编译的.class文件中的一些数据，它还
                    包括了关于类，方法， 接口中常量，还包括字符串常量。
        例子2：
            // JVM使用常量池管理字符串直接量的情形
            public class StringCompareTest{
                public static void main(String[] args) {
                    //s1直接引用常量池中的 "你好世界！"
                    String s1 = "你好世界";
                    String s2 = "你好";
                    String s3 = "世界";

                    // s4 后面的字符串值可以直接在编译时就确定下来
                    // s4 直接引用常量池中的 "你好世界！"
                    String s4 = "你好" + "世界";
                    
                    // s5 后面的字符串值可以直接在编译时就确定下来
                    // s5 直接引用常量池中的 "你好世界！"
                    String s5 ="你" + "好" + "世" + "界";

                    // s6 后面的字符串不能在编译时候就确定值
                    // 所以 s6 不能引用常量池的字符串
                    String s6 = s2 + s3;

                    // 使用 new 调用构造器将会创建一个新的 String 对象
                    // s7 引用堆内存中新创建的 String 对象
                    String s7 = new String("你好世界");

                    System.out.println(s1 == s4);   // out: true
                    System.out.println(s1 == s5);   // out: true
                    System.out.println(s1 == s6);   // out: false
                    System.out.println(s1 == s7);   // out: false
                }
            }
            程序说明:
                1. JVM常量池保证相同的字符串直接量只有一个，不会产生多个副本。例子中 s1, s4, s5所引用的字符串
                    可以在编译期就确定下来，因此他们都将引用常量池中同一个字符串的对象
                2. 使用 new String()创建的字符串对象是运行时创建出来的，它被保存在堆内存中，不会放入常量池
        例子3：
            // 重写euqals()方法
             class Person{
                private String name;
                private String idStr;
                public Person(){}
                public Person(String name, String idStr){
                    this.name = name;
                    this.idStr = idStr;
                }
                public void setName(String name){
                    this.name = name;
                }
                public String getName(){
                    return this.name;
                }
                public void setIdStr(String idStr){
                    this.idStr = idStr;
                }
                public String getIdStr(){
                    return this.idStr;
                }
                // 重写 equals()方法， 提供自定义的相等标准
                public boolean equals(Object obj){
                    // 如果两个对象为同一个对象
                    if(this == obj)
                        return true;
                    // 只有当 obj 是 Person 对象
                    // obj.getClass() == Person.class 判断obj是否是Person类的实例
                    if (obj != null && obj.getClass() == Person.class){
                        Person personObj = (Person)obj;
                        // 并且当前对象的 idStr 与 对象的 idStr 相等时才可以判断两个对象相等
                        if (this.getIdStr().equals(personObj.getIdStr())){
                            return true;
                        }
                    }
                    return false;
                }
            }
            public class OverrideEqualsRight{
                public static void main(String[] args) {
                    Person p1 = new Person("孙悟空", "123456789");
                    Person p2 = new Person("孙行者", "123456789");
                    Person p3 = new Person("孙悟饭", "1010001010");
                    // p1 和 p2 的 idStr 相等， 所以输出true
                    System.out.println("p1和p2是否相等： " + p1.equals(p2));
                    // p2 和 p3 的 idStr 不相等， 所以输出 false
                    System.out.println("p2和p3是否相等： " + p2.equals(p3));
                }
            }    
            程序说明：
                1. 用于比较的 equals() 方法是可以重写的，可以加上自己需要的判断规则
                2. Person类重写了equals()方法，指定了 Person 对象和其他对象相等的标准(equals方法体代码)：另一个
                    对象必须是Person类的实例，且两个 Person 对象的 idStr 相等，即可判断两个 Person 对象相等；在
                    这种判断标准下，就是只要两个 Person 对象的身份证字符串相等，即可判断相等


3. 类成员
    3.1 理解类成员
        说明:
            1. static 关键字修饰的成员就是类成员, 包括: 类变量, 类方法, 静态初始化块, 内部类(包括接口,枚举)
            2. static 关键字不能修饰构造器, static 修饰的类成员属于整个类, 不属于单个实例
            3. static 关键字规则: 类成员(包括方法, 初始化块, 内部类和枚举类)不能访问实例成员(包括成员变量, 方法,
                初始化块, 内部类和枚举类). 因为类成员是属于类的, 类成员的作用域比实例成员的作用域更大, 完全可能出
                现类成员已经初始化完成, 但实例成员还不曾初始化的情况, 如果允许类成员访问实例成员将会引起大量的错误

        类变量:
            1. 类变量属于整个类, 当系统第一次准备使用该类时, 系统会为该类变量分配内存空间, 类变量开始生效,直到该
                类被卸载, 该类变量占用的内存空间才会被系统的垃圾回收机制回收. 类变量的生存范围几乎是等同于该类的生
                存范围
            2. 类变量可以通过 类.类变量 或者 类的对象.类变量 的形式来访问. 对象不拥有对应类的类变量, 当通过对象来
                访问类变量只是一种假象, 实际上依然访问的是该类的类变量. 所以可以理解为: 当通过对象来访问类变量时,
                系统会在底层转换为通过该类来访问类变量
            3. 同一个类的所有对象访问类变量时, 实际上访问的都是该类所持有的变量, 即同一个类的所有实例的类变量共享同
                一块内存区

        类方法:
            1. 类方法也是属于类, 可通过 类.类方法 或 实例.类方法 来调用. 
            2. 与类变量一样, 使用对象来调用类方法, 其效果也与采用类来调用方法完全一样
            3. 当使用实例来访问类成员时, 实际上依然是委托该类来访问类成员, 即使某个实例为null, 它也可以访问它所属类
                的类成员(例子1) 
            4. 3 的补充: 如果一个null对象访问实例成员(包括实例方法和实例变量), 将引发 NullPointerExamption 异常,
                因为null表明这个实例根本不存在, 所以它的实例变量和实例方法自然也就不存在

        静态初化块:
            1. 静态初始化块用于执行类初始化动作, 在类的初始化阶段, 系统会调用该类的静态初始化块来对类进行初始化. 一旦
                该类的初始化结束后, 静态初始化块将永远不会获得执行的机会（静态初始化块就是 static 修饰的初始化块(如：
                static{代码})，只在第一次加载类的时候只执行一次）
            2. 静态初始化块 非静态初始化块 构造函数等执行顺序
                2.1 静态初始化块的优先级最高，也就是最先执行，并且仅在类第一次被加载时执行
                2.1 非静态初始化块和构造函数后执行，并且在每次生成对象时执行一次；
                2.3 非静态初始化块的代码会在类构造函数之前执行。因此若要使用，应当养成把初始化块写在构造函数之前的习惯，
                    便于调试；
                2.4 静态初始化块既可以用于初始化静态成员变量，也可以执行初始化代码；
                2.5 非静态初始化块可以针对多个重载构造函数进行代码复用。
        例子1:
            public class NullAccessStatic{
                private static void test(){
                    System.out.println("static修饰的类方法!");
                }
                public static void main(String[] args) {
                    // 定义一个 NullAccessStatic 变量, 其值为 null
                    NullAccessStatic nas = null;
                    // 使用 null 对象调用所属类的静态方法
                    nas.test();  // out: "static修饰的类方法!"
                }
            }

    3.2 单例(Singleton)类
        说明:
            1. 如果一个类始终只能创建一个实例, 则这个类被称为单例类(例子1)  
            2. 通过将构造器使用 private 修饰, 从而把该类的所有构造器隐藏起来
            3. 一旦把该类的构造器隐藏起来, 就需要提供一个 public 方法作为该类的访问点, 用于创建该类的对象, 且该方法
                必须使用 static 修饰, (因为调用该方法之前还不存在对象, 因此调用该方法的不可能是对象, 只能是类)
            4. 该类还必须缓存已经创建的对象, 否则该类无法知道是否曾经创建过对象, 也就无法保证只创建一个对象. 为此该类
                需要使用一个成员变量来保存曾经创建的对象, 因为该成员变量需要被上面的静态方法访问, 所以成员变量必须使
                用 static 修饰
        例子1:
            class Singleton{
                // 使用一个类变量来缓存曾经创建的实例
                private static Singleton instance;
                // 对构造器使用 private 修饰, 隐藏该构造器
                private Singleton(){}
                // 提供一个静态方法, 用于返回 Singleton 实例
                // 该方法可以加入自定义控制, 保证只产生一个 Singleton 对象
                public static Singleton getInstance(){
                    // 如果 instance 为 null, 则表明还不曾创建 Singleton 对象
                    // 如果 instance 不为 null, 则表明已经创建了 Singleton 对象
                    // 将不会创建新的实例
                    if (instance == null){
                        // 创建一个 Singleton 对象, 并将其缓存
                        instance = new Singleton();
                    }
                    return instance;
                }
            }
            public class SingletonTest{
                public static void main(String[] args) {
                    // 创建 Singleton 对象不能通过构造器
                    // 只能通过 getInstance 方法来得到实例
                    Singleton s1 = Singleton.getInstance();
                    Singleton s2 = Singleton.getInstance();
                    System.out.println(s1 == s2);  // out: true
                }
            }
            程序说明：
                1. 上面的例子中通过 private 修饰构造器， 从而隐藏了该类创建对象的渠道
                2. 通过 public 修饰的 getInstance 方法提供的自定义控制(这也是封装的优势：不允许自由访问类的成员变量和
                    实现细节，而是通过方法来控制合适的暴露)，从而保证 Singleton 类只能产生一个实例。所以在 Singleton 
                    类的 main() 方法中，看到两次产生的 Singleton 对象实际上是同一个对象
 

4. final 修饰符
    4.1 final 成员变量
        说明：
            1. final 关键字可用于修饰类，变量和方法，用于表示修饰的类，方法和变量不可改变
            2. final 修饰变量时，表示该变量一旦获得了初始值就不可改变(不能被重新赋值)，final 可修饰成员变量(类变量和实例变量)
                也可修饰局部变量和形参
            3. final 修饰的成员变量必须由程序员显式的指定初始值（例子1）
            4. 类变量：必须在静态初始化块中指定初始值或者在声明该类变量时指定初始值，而且只能在这两个地方的其中之一指定
            5. 实例变量：必须在非静态初始化块，声明该实例变量或构造器中指定初始值， 而且只能在这三个地方的其中之一指定
            6. 实例变量不能在静态初始化块中指定初始值，因为静态初始化块时静态成员，不可访问实例变量--非静态成员
            7. 类变量也不能在普通初始化块中指定初始值，因为类变量在类初始化阶段已经被初始化了， 普通初始化块不能再对其重新赋值
            8. 如果在构造器或初始化块中对 final 成员变量进行初始化，那么在初始化之前不能访问成员变量的值， 否则报错（例子2）
        例子1： 
            // final 修饰成员变量的效果
            public class FinalVariableTest{
                // 定义成员变量时指定默认值，合法
                final int a = 6;
                // 下面的变量将在构造器或者初始化块中分配初始值
                final String str;
                final int c;
                // 下面的类变量没有指定初始值,只能在静态初始化块中指定初始值
                final static double d;
                // 既没有指定默认值，又没有在初始化块或构造器中指定初始值
                // 下面定义的 ch 实例变量不合法
                // final char ch;
                // 初始化块， 可对没有指定默认值的实例变量指定初始值
                {
                    // 在初始化块中为实例变量指定初始值， 合法
                    str = "hello";
                    // 定义a重新赋值， 因此下面的语句非法
                    // a = 9;
                    System.out.println("普通初始化块");
                }
                // 静态初始化块中为类变量指定初始值， 合法
                static {
                    d = 5.6;
                    System.out.println("静态初始化块");
                }
                // 构造器中既可以对没有指定默认值， 又没有在初始化块中指定默认值的实例变量指定初始值
                public FinalVariableTest(){
                    // 如果在初始化块中已经为 str 指定了初始值
                    // 那么在构造器中不能对 final 变量重新赋值，下面的赋值语句非法
                    // str = "java";
                    c = 5;
                    System.out.println("构造器");
                }
                public static void main(String[] args) {
                    FinalVariableTest ft = new FinalVariableTest();
                    System.out.println(ft.a);
                    System.out.println(ft.c);
                    //The static field FinalVariableTest.d should be accessed in a static way
                    System.out.println(FinalVariableTest.d);
                }
            }
        例子2： 
            // 在普通初始化块中进行初始化之前访问 final 修饰的实例变量的值，报错
            public class FinalErrorTest{
                // 定义一个 final 修饰的实例变量, 定义时未指定值
                // 系统不会为 final 修饰的成员变量进行默认的初始化
                final int age;
                // 普通初始化块
                {
                    // age 没有初始化， 所以此处访问age的值报错
                    // The blank final field age may not have been initialized
                    // System.out.println(age);
                    age = 6;
                    System.out.println(age);
                }
                public static void main(String[] args){
                    new FinalErrorTest();
                }
            }

    4.2 final 局部变量
        说明：
            1. 系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化
            2. final 修饰的局部变量，既可在定义时指定默认值(定义时指定，后面的代码中不能再赋值)，也可不指定默认值，在后面的代码中
                对该 final 变量赋初始值，但只能一次， 不可重复。
            3. final 修饰形参时，因为形参在调用该方法时，由系统根据传入的参数来完成初始化，因此使用 final 修饰的形参不能被赋值

        例子： 
            public class FinalLocalVariableTest{
                public void test(final int a){
                    // 不能对 final 修饰的形参赋值，下面的语句非法
                    // a = 5;
                    System.out.println("不能对 final 修饰的形参赋值, 需由调用时传入参数完成初始化！" + a);
                }      
                public static void main(String[] args) {
                    // 定义 final 局部变量时指定默认值，则 str 变量无法重新赋值
                    final String str  = "Hello";
                    // 下面的语句非法
                    // str = "java";
                    // 定义局部变量时没有指定默认值，则 d 变量可被赋值一次（仅一次）
                    final double d;
                    // 第一次赋值
                    d = 5.6;
                    // 对 final 修饰的局部变量第二次赋值，下面语句非法
                    // d = 3.4;
                    System.out.println(str + " " + d);

                    FinalLocalVariableTest fl = new FinalLocalVariableTest();
                    fl.test(100);
                    fl.test(250);
                }        
            }

    4.3 final 修饰基本类型变量和引用类型变量的区别
        说明：
            1. 使用 final 修饰基本类型变量时， 不能对基本类型变量重新赋值，因此基本类型变量不能被改变
            2. 使用 final 修饰引用类型，因为引用类型保存的仅仅是一个引用，final 只保证这个引用类型变量所引用的地址不会改变，即一直
                引用同一个对象，但这个对象完全可能发生改变
        
        例子： 
            import java.util.Arrays;

            class PersonFinal {
                private int age;
                public PersonFinal(){}
                // 有参数的构造器
                public PersonFinal(int age){
                    this.age = age;
                }
                // setAge 和 getAge 方法
                public void setAge(int age){
                    this.age = age;
                }
                public int getAge(){
                    return this.age;
                }
            }
            public class FinalReferenceTest{
                public static void main(String[] args) {
                    // final 修饰数组变量，iArr 是一个引用变量
                    final int[] iArr = {5, 6, 9, 12, 2, 55, -1};
                    System.out.println(Arrays.toString(iArr));   // out: [5, 6, 9, 12, 2, 55, -1]
                    // 对数组元素进行排序， 合法
                    Arrays.sort(iArr);
                    System.out.println(Arrays.toString(iArr));   // out: [-1, 2, 5, 6, 9, 12, 55]
                    // 对数组元素赋值，合法
                    iArr[2] = -8;
                    System.out.println(Arrays.toString(iArr));   // out: [-1, 2, -8, 6, 9, 12, 55]
                    // 下面语句对 iArr 重新赋值，非法
                    // iArr = null;
                    // final 修饰 PersonFinal 变量， p 是一个引用变量
                    final PersonFinal p = new PersonFinal(45);
                    // 改变 PersonFinal 对象的 age 实例变量，合法
                    p.setAge(23);
                    System.out.println(p.getAge());   // out: 23
                    // 下面的语句对 p 重新赋值，非法
                    // p = null;
                }
            }
            程序说明：
                1. 使用 final 修饰的引用类型变量不能被重新赋值，但可以改变引用类型变量所引用对象的内容。 例如上面 iArr 变量所引用的数组
                    对象， final 修饰后的 iArr 变量不能被重新赋值，但是 iArr 所引用数组的数组元素可以改变。
                2. p 变量也使用 final 修饰，表明 p 变量不能被重新赋值，但 p 变量所引用的 PersonFinal 对象的成员变量的值可以被改变


    4.4 可执行 "宏替换" 的 final 变量 
        说明：
            1. 对于一个final 变量来说，不管它是类变量，实例变量，还是局部变量，只要该变量满足下面三个条件，那么这个 final 变量就不再是一个
                变量，而是相当于一个直接量（例子1）
                1.1 使用 final 修饰符修饰
                1.2 在定义该 final 变量时指定了初始值
                1.3 该初始值可以在编译时就被确定下来
            2. final修饰符的一个重要用途就是定义"宏变量"。当定义 final 变量时就为该变量指定了初始值，而且该初始值可以在编译时就确定下来，那么
                这个 final 变量本质上就是一个 "宏变量"，编译器会把程序中所有用到该变量的地方直接替换成该变量的值
            3. 对于 final 实例变量而言，只有定义该变量时指定了初始值才会有 "宏变量" 的效果
            4. Java会使用常量池来管理曾经用到过的字符串直接量，例如执行：String a = "Java"; 语句之后，常量池中就会缓存一个字符串"Java"；如果
                程序再次执行String b = "Java"; 系统就会让 b 直接指向常量池中的 "Java" 字符串， 因此 a == b 将会返回 True (例子2)
        例子1： 
            // 满足说明1的final修饰的变量相当于一个直接量
            public class FinalLocalTest{
                public static void mian(String[] args){
                    // 定义一个普通的局部变量
                    final int a = 5;
                    System.out.println(a);
                }
            }
            程序说明：
                1. 对于上面的程序，变量 a 其实根本不存在，当程序执行System.out.println(a);代码时，实际转换为执行System.out.println(a5;
        
        例子2：
            public class FinalABTest{
                public static void main(String[] args){
                    final String a = "Java";
                    final String b = "Java";
                    System.out.println("a == b :" + (a == b));   // out: a == b :true
                    System.out.println("a.equals(b): " + a.equals(b));   // out: a.equals(b): true
                }
            }
        例子3：
            public class StringJoinTest{
                public static void main(String[] args) {
                    String s1 = "学 Java";
                    // s2变量引用的字符串可以在编译时就确定下来
                    // 因此 s2 直接引用常量池已有的 "学 Java" 字符串
                    String s2 = "学 " + "Java";
                    System.out.println("s1 == s2: " + (s1 == s2));  // out: s1 == s2: true
                    // 定义两个字符串直接量
                    String str1 = "学 ";
                    String str2 = "Java";
                    String s3 = str1 + str2;
                    System.out.println("s1 == s3: " + (s1 == s3));   // out: s1 == s3: false
                }
            }
            程序说明：
                1. 对于 s1 和 s2 编译器在编译时就可以确定他们的值，所以系统会让 s2 直接指向常量池中缓存的字符串
                2. 而 s3 的值是由 str1 和 str2 进行连接运算后得到的，由于 str1 和 str2 是普通变量，编译器不会执行 "宏替换"，所以在
                    编译时 s3 的值时无法确定的，也就无法让 s3 指向常量池中缓存的字符串
                3. 让 s1 == s3 为 true 很简单，只要使用 final 修饰 str1 和 str2 两个变量就可以执行 "宏替换"，从而在编译时就确定s3
                    的值，进而让 s3 也指向常量池中缓存的 字符串

    4.5 final 方法
        说明：
            1. final 修饰的方法不可被重写，如：Object类里的 getClass()方法，因为Java不希望任何类重写这个方法，所以使用 final 修饰，
                从而将这个方法密封起来（例子1）
            2. 对于一个 private 修饰的方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法，
            3. rewiew: 如果子类中定义了一个与父类 private 方法由相同方法名，相同形参列表，相同返回值类型的方法，也不是重写父类的 private                
                方法，而是子类重新定义了一个新方法。因此：即使使用 final 修饰一个 private 访问权限的方法，依然可以在其子类中定义与该方法
                具有相同方法名，相同形参列表，相同返回值类型的方法（例子2）
            4. final 修饰的方法仅仅是不能被重写，并不是不能被重载（例子3）
        
        例子1：
            public class FinalMethodTest{
                public final void test(){
                    System.out.println("final 修饰的 Public 访问权限的 test() 方法");
                }
            }
            class sub extends FinalMethodTest{
                // 下面方法定义将出现编译错误，不能重写父类 final 方法
                public void test(){}
            }
        例子2： 
            // 子类定义了和父类(被 private 和final 修饰的) 相同方法名，相同形参列表，相同返回值类型的方法，但不是重写父类方法，是子类重新定义
            public class PrivateFinalMethodTest{
                private final void test(){}
            }
            class sub extends PrivateFinalMethodTest{
                // 下面的方法定义不会出现问题
                public void test(){}
            }
        例子3： 
            public class FinalOverload{
                // final 修饰的方法只是不能被重写，完全可以被重载
                public final void test(){}
                public final void test(String args){}
            }

    4.6 final 类
        说明：
            1. final 修饰的类不可以有子类，如java.lang.Math 类就是一个 final 类，它不可以有子类
            2. 也就是说 final 修饰的类不可以被继承
        例子： 
            public final class FinalClass{}
            // 下面定义的类继承FinalClass类将出现编译错误
            // class Sub entends FinalClass{}

    4.7 不可变类
        说明:
            1. 不可变(immutable)类的意思是创建该类的实例后, 该实例的实例变量不可变
            2. Java 的8个包装类和java.lang.String类都是不可变类,当创建他们的实例后, 其实例的实例变量不可改变
            3. 与不可变类对应的是可变类, 可变类的含义是该类的实例变量是可变的. 大部分时候创建的类都是可变类
            4. 不可变类的实例在整个生命周期中永远处于初始化状态, 它的实例变量不可改变
            5. 问题: 当创建不可变类时, 如果它包含成员变量的类型是可变的, 那么其对象的成员变量的值依然是可变的--这个不可变
                类其实是失败的
            6. 设计不可变类时, 尤其要注意引用类型的成员变量, 如果引用类型的成员变量的类是可变的,就必须采取必要的措施来保护
                该成员变量所引用的对象不是被修改,这样才能创建真正的不可变类 (例子2 多看)

        创建自定义不可变类的规则:
            1. 类添加 final 修饰符, 保证类不被继承
            2. 使用 private 和 final 修饰符来修饰该类的成员变量
            3. 提供带参数构造器, 用于根据传入参数来初始化类里的成员变量
            4. 仅为该列的成员变量提供 getter 方法, 不为该类的成员变量提供 setter 方法, 因为普通方法无法修改 final 修饰的
                成员变量
            5. 在 getter 方法中, 不要直接返回对象本身, 而是克隆对象, 并返回对象的拷贝
            6. 如果有必要，重写 Object 类的 hashCode() 方法和 equals() 方法，equals()方法根据关键成员变量来作为两个对象
                相等的标准，除此之外，还应该保证两个用equals()方法判断为相等的对象的hashCode()也相等(例子4)
        
        例子1:
            // 定义一个不可变的 Address 类, 程序把 Address 类的 detail 和 postCode 成员变量都是用 private 隐藏起来, 并 
            // 使用 final 修饰这两个成员变量, 不允许其他方法修改这两个成员变量的值
            public class Address{
                // 使用 private 和 final 修饰成员变量
                private final String detail;
                private final String postCode;
                // 构造器里初始化两个实例变量
                public Address(){
                    this.detail = "";
                    this.postCode = "";
                }
                public Address(String detail, String postCode){
                    this.detail = detail;
                    this.postCode = postCode;
                }
                // 仅为这两个实例变量提供 getter 方法
                public String getDetail(){
                    return this.detail;
                }
                public String getPostCode(){
                    return this.postCode;
                }
                // 重写 equals() 方法, 判断两个对象是否相等
                public boolean equals(Object obj){
                    if (this == obj){
                        return true;
                    }
                    if (obj != null && obj.getClass() == Address.class){
                        Address ad = (Address)obj;
                        // 当 detail 和 postCode 相等时, 可认为两个 Address 对象相等
                        if (this.getDetail().equals(ad.getDetail()) && this.getPostCode().equals(ad.getPostCode())){
                            return true;
                        }
                    }
                    return false;
                }
                public int hashCOde(){
                    return detail.hashCode() + postCode.hashCode() * 31; 
                }
            }    
            程序说明:
                1. 对于上面的 Address 类, 程序创建了 Address 对象后, 同样无法修改 Address 对象的 detail 和 postCode 
                    实例变量
        例子2:
            class Name{
                private String firstName;
                private String lastName;
                public Name(){}
                public Name(String firstName, String lastName){
                    this.firstName = firstName;
                    this.lastName = lastName;
                }
                // firstName 和 laseName 的 setter 和 getter 方法
                public void setFrisrtName(String firstName){
                    this.firstName = firstName;
                }
                public String getFirstName(){
                    return this.firstName;
                }
                public void setLastName(String lastName){
                    this.lastName = lastName;
                }
                public String getLastName(){
                    return this.lastName;
                }
            }
            public class immutablePerson{
                private final Name name;
                public immutablePerson(Name name){
                    this.name = name;
                }
                public Name getName(){
                    return name;
                }
                public static void main(String[] args){
                    Name n = new Name("悟空", "孙");
                    immutablePerson  p = new immutablePerson(n);
                    // immutablePerson 对象的 name 的 firstName 值为 "悟空"
                    System.out.println(p.getName().getFirstName());  // out: 悟空
                    // 改变 immutablePerson 对象的 name 的 finstName 值
                    n.setFrisrtName("八戒");
                    // immutablePerson 对象的 name 的 firstName 值被改为"八戒"
                    System.out.println(p.getName().getFirstName());  // out: 八戒
                }
            }
            程序说明:
                1. n.setFrisrtName("八戒");这句代码修改了Name对象(可变类的实例)的firstName的值,单由于 immutablePerson
                    类的 name 实例变量引用了该 Name 对象, 这就会导致 immutablePerson 对象的 name 的 firstName 会改变,
                    这就破坏了 immutablePerson 类的初衷
                2. 为了保持immutablePerson 对象的不可变性, 必须保护好 immutablePerson 对象的引用类型的成员变量: name, 
                    让程序无法访问到 immutablePerson 对象的 name 成员变量, 也就无法利用 name 成员变量的可变性来改变 
                    immutablePerson 对象了. 如例子3修改immuablePerson类
        例子3: 
            // 修改immuablePerson类
            class Name{
                // ......
            }     
            public class immutablePerson{
                private final Name name;
                public immutablePerson(Name name){
                    // 设置 name 实例变量为临时创建的 Name 对象, 该对象的 firstName 和 lastName 与 
                    // 传入的 name 参数的 firstName 和 lastName 相同
                    this.name = new Name(name.getFirstName(), name.getLastName());
                }
                public Name getName(){
                    // 返回一个匿名对象, 该对象的 firstName 和 lastName 与 
                    // 该对象里的 name 的 firstName 和 lastName 相同
                    return new Name(name.getFirstName(), name.getLastName());
                }
                public static void main(String[] args){
                    Name n = new Name("悟空", "孙");
                    immutablePerson  p = new immutablePerson(n);
                    // immutablePerson 对象的 name 的 firstName 值为 "悟空"
                    System.out.println(p.getName().getFirstName());  // out: 悟空
                    // 改变 immutablePerson 对象的 name 的 finstName 值
                    n.setFrisrtName("八戒");
                    // immutablePerson 对象的 name 的 firstName 值被改为"八戒"
                    System.out.println(p.getName().getFirstName());  // out: 悟空
                }
            }
            程序说明:
                1. 当程序向 immutablePerson 构造器传入一个Name对象时,该构造器创建 immutablePerson 对象时并不是
                    直接利用已有的 Name 对象(利用已有的 Name 对象有风险,因为这个已有的Name对象是可变的,如果程序改变
                    了这个Name对象,将会导致immuablePerson 对象也发生变化), 而是重新创建了一个 Name 对象来赋给 
                    immutablePerson 对象的 name 实例变量. 当 immutablePerson 对象返回 name 变量时, 它并没有直接
                    把name实例变量返回, 直接返回name实例变量的值也可能导致它所引用的Name对象被修改
        例子4：
            public class ImmutableStringTest{
                public static void main(String[] args) {
                    String str1 = new String("hello");
                    String str2 = new String("hello");
                    System.out.println(str1 == str2);  // out: false
                    System.out.println(str1.equals(str2));  // out: true
                    // 下面两次输出的hashCode 相同
                    System.out.println(str1.hashCode());  // out: 99162322
                    System.out.println(str2.hashCode());  // out: 99162322
                }
            }

    4.8 缓存实例的不可变类
        说明:
            1. 不可变类的实例状态不可改变,可以很方便的被多个对象所共享; 如果程序经常需要使用相同的不可变类实例,则应该
                考虑缓存这种不可变类的实例
            2. 缓存是软件设计中的一个非常有用的模式, 缓存的方式有很多种,下面的例子使用数组来作为缓存池,从而实现一个缓存
                实例的不可变类

        例子:
            class CacheImmutale{
                private static int MAX_SIZE = 10;
                // 使用数组来缓存已有的实例
                private static CacheImmutale[] cache
                    = new CacheImmutale[MAX_SIZE];
                // 记录缓存实例在缓存中的位置, cache[pos-1]是最新缓存的实例
                private static int pos = 0;
                private final String name;
                private CacheImmutale(String name){
                    this.name = name;
                }
                public String getName(){
                    return this.name;
                }
                public static CacheImmutale valueOf(String name){
                    // 遍历已缓存的对象
                    for (int i = 0; i < MAX_SIZE; i++){
                        // 如果已有相同的实例, 则直接返回该缓存的实例
                        if (cache[i] != null && cache[i].getName().equals(name)){
                            return cache[i];
                        }
                    }
                    // 如果缓存池已满
                    if (pos == MAX_SIZE){
                        // 把缓存的第一个对象覆盖, 即把刚刚生成的对象放在缓存吃的最开始位置
                        cache[0] = new CacheImmutale(name);
                        // 把 pos 设为 1
                        pos = 1;
                    }
                    else{
                        // 把新创建的对象缓存起来, pos 加 1
                        cache[pos++] = new CacheImmutale(name);
                    }
                    return cache[pos - 1];
                }
                public boolean equals(Object obj){
                    if (this == obj){
                        return true;
                    }
                    if (obj != null && obj.getClass() == CacheImmutale.class){
                        CacheImmutale ci = (CacheImmutale)obj;
                        return name.equals(ci.getName());
                    }
                    return false;
                }
                public int hashCode(){
                    return name.hashCode();
                }
            }
            public class CacheImmutaleTest{
                public static void main(String[] args) {
                    CacheImmutale c1 = CacheImmutale.valueOf("hello");
                    CacheImmutale c2 = CacheImmutale.valueOf("hello");
                    // 下面的代码将输出true
                    System.out.println(c1 == c2);  // out: true
                }
            }
            程序说明:
                1. 上面的 CacheImmutale 类使用一个数组来缓存该类的对象,这个数组的长度是 MAX_SIZE, 即该类共可以缓存
                    MAX_SIZE个CacheImmutale 对象. 当缓存池已满时, 缓存池采用 "先进先出" 规则来决定那个对象被移出
                    缓存池
                2. 当使用 CacheImmutale 类的 valueOf() 方法来生成对象时, 系统会进行判断, 如果该数组中已经缓存了该类
                    的对象, 系统将不会重新生产对象
                3. CacheImmutale 类能控制系统 CacheImmutale 对象的个数, 需要程序使用该类的 valueof() 方法来得到其
                    对象, 而且程序使用 private 修饰符隐藏该类的构造器, 因此程序只能通过该类提供的 valueof() 方法来
                    获得实例


5. 抽象类
    5.1 抽象方法和抽象类
        说明：
            1. 抽象方法只有方法签名，没有方法实现的方法
            2. 抽象方法和抽象类必须使用 abstract 修饰符来定义，有抽象方法的类只能被定义为抽象类，抽象类里可以没有抽象方法
            3. 归纳：抽象类可用“有得有失”来描述："得"指的是抽象类多了一个能力：抽象类可包含抽象方法；"失"指定是抽象类失去了
                一个能力：抽象类不能用于创建实例
            4. 定义抽象类只需在普通类上增加 abstract 修饰符即可，甚至一个普通类(没有包含抽象方法的类)增加了 abstract 修饰
                符后也将变成抽象类
            5. 定义抽象方法只需要在普通方法上增加 abstract 修饰符，并把普通方法的方法体部分去掉，并在方法体后面增加分号即可
                5.1 如：抽象方法：public abstract void test();  抽象方法，没有方法体(即方法定义后面没有一对花括号)
                5.2 如：普通方法：public void test(){}   普通方法，定义了方法体，但方法体为空
 
        抽象方法和抽象类的规则：
            1. 抽象类和抽象方法必须使用abstract修饰符来修饰，抽象方法不能有方法体
            2. 抽象类不能被实例化，无法使用 new 关键字来调用抽象类的构造器创建抽象类的实例，即使抽象类里不包含抽象方法，
                这个抽象类也不能创建实例
            3. 抽象类可以包含成员变量，方法(普通方法和抽象方法都可以)，构造器，初始化块，内部类(接口，枚举类)5部分，抽象类的
                构造器不能用于创建实例，主要是用于被其子类调用
            4. 含有抽象方法的类(包括直接定义了一个抽象方法，或者继承了一个抽象父类，但没有完全实现父类包含的抽象方法，或实现
                了一个接口，但没有完全实现接口包含的抽象方法三种情况)只能被定义为抽象类
        
        注意：
            1. abstract 修饰类时，表明这个类只能被继承； abstract 修饰方法时: 表明这个方法必须由子类提供实现（重写）
            2. 由于 final 修饰的类不能被继承，final 修饰的方法不能被重写。 所以 final 和 abstract 互斥，不能共存
            3. abstract 也不能用于修饰成员变量，不能用于修饰局部变量，也不能用于修饰构造器
            4. static 修饰的方法是类方法，即通过类可调用该方法，但如果该方法被定义哼了抽象方法，则将导致通过该类来调用方法是出现
                错误(因为调用了一个没有方法体的方法)，所以 static 和 abstract 也互斥(内部类可以共存)，不能同时修饰某个方法
            5. abstract 关键字修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体，因此 abstract 方法也不能定义
                为 private 的访问权限，即 abstract 和 private  关键字也是互斥 
                abstract 和 final private static 这三个关键字互斥(暂理解)，不能同时使用
            
        例子1：
            // 定义一个 Shape 抽象类
            public abstract class Shape{
                {
                    System.out.println("abstract修饰的抽象类,执行 Shape 的普通初始化块。。。");
                }
                private String color;
                // 定义一个计算周长的抽象方法
                public abstract double calPerimeter();
                // 定义一个返回形状的抽象方法
                public abstract String getType();
                // 定义 Shape 的构造器，该构造器并不是用于创建 Shape 对象，而是用于被子类调用的
                public Shape(){}
                public Shape(String color){
                    System.out.println("执行 Shape 的构造器。。。");
                    this.color = color;
                }
                // 定义 color 的 getter 和 setter 方法
                public void setColor(String color){
                    this.color = color;
                }
                public String getColor(){
                    return this.color;
                }
            }
            程序说明：
                1. 抽象的 Shape 类中定义了 两个 抽象方法 calPerimeter() 和 getType() 
                2. Shape 类里既包括了初始化块，也包含了构造器，这些都不是在创建 Shape 对象时被调用的，而是在
                    创建其子类的实例的时被调用

        例子2： 
            // 定义一个三角形普通类，继承 Shape 类， 必须实现 Shape 类的所有抽象方法
            public class Triangle extends Shape{
                // 定义三角形的三条边
                private double a;
                private double b;
                private double c;
                public Triangle(String color, double a, double b, double c){
                    super(color);
                    this.setSides(a, b, c);
                }
                public void setSides(double a, double b, double c){
                    if (a >= b + c || b >= a + c || c >= a + b){
                        System.out.println("三角形两边之和必须大于第三边");
                        return;
                    }
                    this.a = a;
                    this.b = b;
                    this.c = c;
                }
                // 重写 Shape 类的计算周长的抽象方法
                public double calPerimeter(){
                    return a + b + c;
                }
                // 重写 Shape 类的返回形状的方法
                public String getType(){
                    return "三角形";
                }
            }
            程序说明：
                1. 继承了Shape类，并实现了Shape类的两个抽象方法，是一个普通类，因此可以创建 Triangle 类的实例   
                    可以让一个 Shape 类型的引用变量指向 Triangle 对象

        例子3： 
            // 再定义一个 Cricle 普通类，继承 Shape 类
            public class Circle extends Shape{
                private double radius;
                public Circle(String color, double radius){
                    super(color);
                    this.radius = radius;
                }
                public void setRadius(double radius){
                    this.radius = radius;
                }
                // 重写 Shape 类的计算周长的抽象方法
                public double calPerimeter(){
                    return 2 * Math.PI * radius;
                }
                // 重写Shape 类的反会形状的抽象方法
                public String getType(){
                    return getColor() + " 圆形";
                }
                public static void main(String[] args) {
                    Shape s1 = new Triangle("黑色", 3, 4, 5);
                    Shape s2 = new Circle("黄色", 3);
                    System.out.println(s1.getType());
                    System.out.println(s1.calPerimeter());
                    System.out.println(s2.getType());
                    System.out.println(s2.calPerimeter());
                }
            }
            程序说明：
                1. main() 方法中定义了两个 Shape 类型的引用变量，他们分别指向 Triangle 对象和 Circle 对象
                2. 由于在 Shape 类中定义了 calPerimeter() 方法和 getType() 方法，所以程序可以直接调用 s1 变量
                    和 s2 变量的 calPerimeter() 方法和 getType() 方法， 无需强制类型转换为其子类类型 

    5.2 抽象类的作用
        说明：
            1. 抽象类不能创建实例, 只能当成父类来被继承; 抽象类是从多个具体类中抽象出来的父类, 它具有更高层次的抽象
            2. 抽象类是一种常见的简单的模版模式设计模式之一

        模版模式设计规则:
            1. 抽象父类可以只定义需要使用的某些方法, 把不能实现的部分抽象成抽象类, 留给其子列去实现
            2. 父类中可能包含需要使用其他系列方法的方法, 这些被调方法既可以由父类实现, 也可以由其子类实现
        例子1:
            // 模版模式的范例
            public abstract class SpeedMeter{
                // 定义转速
                private double turnRate;
                public SpeedMeter(){
                }
                // 把返回车轮半径的方法定义为抽象方法
                public abstract double getRadius();
                public void setTurnRate(double turnRate){
                    this.turnRate = turnRate;
                }
                // 定义计算速度的通用公式
                public double getSpeed(){
                    // 速度等于车轮半径 * 2 * PI * 转速
                    return java.lang.Math.PI * 2 * getRadius() * turnRate;
                }
            }
            程序说明:
                1. 上面程序定义了一个 抽象类 abstract SpeedMeter, 里面定义了两个通用方法, setTurnRate 和 
                    getSpeed 方法, 还定义了一个抽象方法, getRadius() 
                2. 抽象类 abstract SpeedMeter,只能被继承, 并且抽象方法 getRadius()必须在子类中实现其方法

        例子2: 
            public class CarSpeedMeter extends SpeedMeter{
                public double getRadius(){
                    return 0.28;
                }
                public static void main(String[] args) {
                    CarSpeedMeter csm = new CarSpeedMeter();
                    csm.setTurnRate(15);
                    System.out.println(csm.getSpeed());  // out: 26.389378290154266
                }
            }
            程序说明:
                1. CarSpeedMeter 类继承了 SpeedMeter这个抽象方法, 并且实现了抽象方法 getRadius, 
                2. CarSpeedMeter 是一个普通类, 可以创建类的对象, 也可以调用父类的方法实现获取当前速度 


6. Java 8 改进的接口
    6.1 接口的概念
        说明:
            1. 接口(interface) 是一种更加特殊的"抽象类"; 接口里不能包含普通方法, 接口里的所有方法都是抽象方法;
                Java8 允许在接口中定义默认方法, 默认方法可以提供方法实现
            2. 接口定义了一种规范, 接口定义了某一批类所需要遵守的规范, 接口不关心这些类的内部状态数据, 也不关心这
                些类里方法的实现细节, 接口只规定这批类里必须提供某些方法, 提供这些方法的类就可以满足实际需要; 而类 
                是一种具体实现体
            3. 接口是从多个相似类中抽象出来的规范, 接口不提供任何实现, 接口体现的是规范和实现分离的设计哲学, 是一
                中松耦合的设计
            4. 接口定义的是多个类共同的公共行为规范, 这些行为是与外部交流的通道, 这就意味着接口里通常是定义一组公
                用的方法

    6.2 Java 8 中接口的定义
        说明:
            1. 修饰符可以是 public 或者省略, 如果省略了 public 访问控制符, 则默认采用包访问权限访问控制符, 即只有
                在相同的包结构下才可以访问该接口
            2. 接口名应与类名采用相同的命名规则, 多个有意义的单词连缀而成,单词首字母大写
            3. 只有在Java8以上的版本中才允许在接口中定义默认方法, 类方法; 接口中的默认方法, 默认是使用 default 修
                饰, 该方法不能使用 static 修饰
            4. 由于接口定义的是一种规范, 因此接口里不能包含构造器和初始化块
            5. 接口里可包含:成员变量(只能是静态常量), 方法(只能是抽象实例方法, 类方法或默认方法), 内部类(包括内部接
                口和枚举)
            6. 接口里的访问权限都是 public 访问权限
            7. 接口中的成员变量, 不管是否使用 public final static 修饰符,接口里的成员变量总是使用这三个修饰符来修饰
            8. 因为接口里没有构造器和初始化块, 所以接口里定义的成员变量只能在定义时指定默认值(例子1)
            9. 接口里的普通方法总是使用 public abstract 来修饰, 接口里的普通方法不能有方法体; 但是类方法, 默认方法
                都必须有方法体
            10. 接口里定义的内部类, 内部接口, 内部枚举默认都是采用 public static 修饰符, 不管定义时是否指定这两个修
                饰符, 系统都是自动使用 public static 对他们进行修饰
            11. 接口可被当成一个特殊的类, 因此一个 Java 源文件里最多只能有一个 public 接口, 且这个源文件的主文件名
                必须和 public 接口名相同
            
        接口定义的基本语法:(例子2)
            [修饰符] interface 接口名 extends 父接口1, 父接口2...{
                零个到多个常量定义...
                零个到多个抽象方法定义...
                零个到多个内部类, 接口, 枚举定义...
                零个到多个默认方法或类方法定义...
            }    

        例子1:
            // 系统自动为接口里定义的成员变量增加 public static final 修饰符 
            int MAX_SIZE = 50;
            public static final int MAX_SIZ = 50; 

        例子2: 
            // 定义一个接口
            public interface Output{
                // 接口里定义的成员变量只能是常量
                int MAX_CACHE_LINE = 50;

                // 接口里定义的普通方法只能是抽象方法
                void out();
                void getData(Strng msg);

                // 在接口中定义默认方法,需要使用 default 修饰
                default void print(String... msgs){
                    for (String msg : msgs){
                        System.out.println(msg);
                    }
                }

                // 在接口中定义默认方法, 需要使用 default 修饰
                default void test(){
                    System.out.println("默认的 test() 方法");
                }
                
                // 在接口中定义类方法, 需要使用 static 修饰
                static String staticTest(){
                    return "接口里的类方法";
                }
            }
            程序说明:
                1. 上面程序定义了一个 Output 接口, 包含一个成员变量: MAX_CACHE_LINE, 还定义了两个普通方法, 取
                    数据的 getData() 方法和表示输出的 out() 方法,
                2. 如上程序: 定义了 Output 接口的规范: 只要某个类能取的数据, 并可以将数据输出, 那它就是一个输出
                    设备
    
    6.3 接口的继承
        说明:
            1. 接口和类的区别就是接口完全支持多继承; 即一个接口可以有多个直接父接口(例子1)
            2. 和类继承相似, 子接口扩展某个父接口, 将会获得父接口的所有抽象方法和常量

        例子1:
            interface interfaceA{
                int PROP_A = 5;
                void testA();
            }
            interface interfaceB{
                int PROP_B = 6;
                void testB();
            }
            interface interfaceC extends interfaceA, interfaceB{
                int PROP_C = 7;
                void testC();
            }
            public class InterfaceExtendsTest{
                public static void main(String[] args) {
                    System.out.println(interfaceC.PROP_A);
                    System.out.println(interfaceC.PROP_B);
                    System.out.println(interfaceC.PROP_C);
                }
            }
            程序说明:
                1. 程序中 interfaceC 接口继承了 interfaceA 和 interfaceB, 所以 interfaceC 中获得了他们的常量
                    所以在 main() 方法中可以通过 interfaceC 来访问 PROP_A, PROP_B 和 PROP_C 常量
            
        6.4 使用接口
            说明:
                1. 接口不能用于创建实例, 但接口可以用于声明引用类型变量
                2. 使用接口来声明引用类型变量时, 这个引用类型的变量必须引用到其实现类的对象
                3. 一个类可以实现一个或多个接口, 继承使用 extends 关键字, 实现则用 implements 关键字
                4. 实现接口方法时, 必须使用 public 访问控制符, 因为接口里的方法都是 public 的, 而子类(相当于实现类)
                    重写父类方法时访问权限只能更大或者相等, 所以实现类实现接口里的方法只能使用 public 访问权限
                5. 接口不能显式的继承任何类, 但所有接口类型的引用变量都可以直接赋值给 Object 类型的引用变量
            
            接口的用途:
                1. 定义变量, 也可用于进行强制类型转换
                2. 调用接口中定义的常量
                3. 被其他类实现
            
            类实现接口的语法:
                [修饰符] class 类名 extends 父类1 implements 接口1, 接口2...{
                    // 类体部分
                }
                语法说明:
                    1. 实现接口和继承父类相似,一样可以获得所实现接口里定义的常量(成员变量), 方法(包括抽象方法和
                        默认方法)
                    2. 让类实现接口需要类定义后增加 implemrnts 部分, 当需要实现多个接口时, 多个接口之间使用英文逗号
                        隔开, 
                    3. 一个类只能继承一个父类, 但可以继承多个接口, implements 部分必须放在 extends 部分之后
                    4. 一个类实现了一个或多个接口之后, 这个必须完全实现这些接口里所定义的全部抽象方法(也就是重写这些
                        抽象方法); 否则, 该类将保留从父类接口里继承到的抽象方法, 该类也必须定义成一个抽象类
            例子:
                // 定义一个 Product 接口
                interface Product{
                    int getProductTime();
                }
                // 让 Printer 类实现 Output 和 Product 接口
                public class Printer implements Output, Product{
                    private String[] printData = new String[MAX_CACHE_LINE];
                    // 用以记录当前需打印的作业数
                    private int dataNum = 0;
                    public void out(){
                        // 只要有作业, 就继续打印
                        while (dataNum > 0){
                            System.out.println("打印机打印: " + printData[0]);
                            // 把作业队列整体前移一位, 并将剩下额作业数减 1
                            System.arraycopy(printData, 1, printData, 0, --dataNum);
                        }
                    }
                    public void getData(String msg){
                        if (dataNum >= MAX_CACHE_LINE){
                            System.out.println("输出队列已满, 添加失败");
                        }
                        else{
                            // 把打印数据添加到队列, 已保存数据的数量加1
                            printData[dataNum++] = msg;
                        }
                    }
                    public int getProductTime(){
                        return 45;
                    }
                    public static void main(String[] args){
                        // 创建一个 Printer 对象, 当成 Output 使用
                        Output o = new Printer();
                        o.getData("轻量级 Java EE 企业应用实战");
                        o.getData("疯狂 Java 讲义");
                        o.out();
                        o.getData("疯狂 Android 讲义");
                        o.getData("疯狂 Ajux 讲义");
                        o.out();

                        // 调用 Output 接口中定义的默认方法
                        o.print("孙悟空", "猪八戒", "白骨精");
                        o.test();

                        // 创建一个 Printer 对象, 当成 Product 使用 
                        Product p = new Printer();
                        System.out.println(p.getProductTime());
                        // 所有接口类型的引用变量可直接赋给 Object 类型的变量
                        Object obj = p;
                        System.out.println(obj);  // out: app.Printer@16f65612
                        System.out.println(obj.toString());
                    }
                }

    6.5 接口和抽象类
        相同点:
            1. 接口和抽象类都不能被实例化, 它们都位于继承树的顶端, 用于被其他类实现和继承
            2. 接口和抽象类都可以包含抽象方法, 实现接口或继承抽象类的普通子类都必须实现这些抽象方法

        不同点:
            1. 接口作为一种规范和实现分离的设计哲学, 对接口的实现者而言, 接口规定了实现者必须向外提供那些服务(以方
                法的形式提供); 对 接口的调用这而言, 接口规定了调用者可以调用那些服务, 以及如何调用这些服务(就是如
                何来调用方法).
            2. 当一个程序中使用接口时, 接口是多个模块间的耦合标准; 当多个应用程序之间使用接口时, 接口是多个程序
                之间的通讯标准
            3. 抽象类是一种模版式设计方式, 抽象类作为多个子类的抽象父类, 可以被当成系统实现过程中的中间产品, 这个
                中间产品已经实现了系统的部分功能(那些已经实现的方法), 但这个产品依然不呢个当成最终产品, 必须有更
                进一步的完善, 这种完善可能有几种不同方式

        接口和抽象类在用法上的不同:
            1. 接口里只能包含抽象方法和默认方法, 不能为普通方法提供方法实现; 抽象类则完全可以包含普通方法
            2. 接口里不能定义静态方法; 抽象类里可以定义静态方法
            3. 接口里只能定义静态常量, 不能定义普通成员变量; 抽象类里则既可以定义普通成员变量, 也可以定义静态常量
            4. 接口里不包含构造器; 抽象类里可以包含构造器, 抽象类里的构造器并不是用于创建对象, 而是让其子类调用这
                些构造器来完成属于抽象类的初始化操作
            5. 接口里不包含初始化块; 单抽象类则完全可以包含初始化块
            6. 一个类最多只能有一个直接父类, 包括抽象类; 但一个类可以直接实现多个接口, 通过实现多个接口可以弥补Java
                但继承的不足

        
    6.6 面向接口编程
        说明:
            接口体现的是规范和实现分离的设计哲学, 充分利用接口可以极好的降低程序各模块之间的耦合, 从而提高系统的可扩
            展性和可维护性

        1. 简单工厂模式
            需求(场景): 假设程序中有个 Computer 类需要组合一个输出设备
            解决方案: 1.1 直接让 Computer 类组合一个 Printer 
                     1.2 让 Computer 类组合一个 Output 
            分析: 工厂模式简易让 Computer 类组合一个 Output 类型的对象, 将 Computer 类与 Printer 类完全分离

            例子:
            // Computer 类的定义代码
            public class Computer{
                private Output out;
                public Computer(Output out){
                    this.out = out;
                }
                // 定义一个模拟获取字符串输入的方法
                public void keyIn(String msg){
                    out.getData(msg);
                }
                // 定义一个模拟打印的方法
                public void print(){
                    out.out();
                }
            }
            程序说明:
                1. Computer 类已经完全与 Printer 类分离, 只与 Output 接口耦合. Computer 类不再负责创建 Output 对象,
                    系统提供一个 Output 工厂来负责生成 Output 对象
            
            例子2:
            // 定义一个 OutputFactory 工厂类
            public class OutputFactory{
                public Output getOutput(){
                    // return new Printer();
                    return new BetterPrinter();
                }
                public static void main(String[] args){
                    OutputFactory of = new OutputFactory();
                    Computer c = new Computer(of.getOutput());
                    c.keyIn("轻量级 Java EE 企业应用实战");
                    c.keyIn("疯狂 Java 讲义");
                    c.print();
                }
            } 
            程序说明:
                1. OutputFactory 类只包含了一个 getOutput() 方法, 该方法返回一个 Output 的实现类的实例, 该方法负责
                    创建 Output 实例, 具体创建哪一个实现类的对象由该方法决定(具体由该方法中 return 后面的实现类的实例
                    决定, 也可以增加更复杂逻辑的代码, 能力不够啊 苏沐橙)

            例子3:
            // 定义一个 BetterPrinter 类
            public class BetterPrinter implements Output{
                private String[] printData = new String[MAX_CACHE_LINE * 2];
                // 用以记录当前需要打印的作业数
                private int dataNum = 0;
                public void out(){
                    // 只要有作业, 就继续打印
                    while (dataNum > 0){
                        System.out.println("高速打印机正在打印:" + printData[0]);
                        // 把作业队列整体前移一位, 并将剩下额作业数减 1
                        System.arraycopy(printData, 1, printData, 0, --dataNum);
                    }
                }
                public void getData(String msg){
                    if (dataNum >= MAX_CACHE_LINE * 2){
                        System.out.println("输出队列已满, 添加失败");
                    }
                    else{
                        // 把打印数据添加到队列里, 已保存数据的数量加1
                        printData[dataNum++] = msg;
                    }
                }
            }
            程序说明:
                1. BetterPrinter 类和 Printer 类一样, 也是实现类 Output 接口的实现类, 因此也可以当成 Output 对象
                    使用, 
                2. 通过这种方式, Computer 调用 Output 接口, 而 OutputFactory 则负责调用 Output 的实现类
                3. 把所有生成 Output 对象的逻辑集中在 OutputFactory 工厂类中管理, 而所有需要使用 Output 对象的类只
                    需与 Output 接口耦合, 而不是与具体的实现类耦合
        



