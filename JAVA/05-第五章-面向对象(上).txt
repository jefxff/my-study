0. 概述
    1. Java类可被认为是一种自定义的数据类型, 可以使用类定义变量, 所有使用类定义的变量都是引用变量,它
        们将会引用到类的对象;
    2. 面向对象三大特征: 封装, 继承, 多态

1. 类和对象
    1.1 定义类
        说明:
            面向对象程序设计过程中有两重要概念: 类(class)和对象(object, 也被称为实例, instance), 其中
            类是某一批对象的抽象, 也可以将类理解为某一种概念; 对象才是一个具体存在的实体.
        
        类的作用:
            1. 定义变量 
            2. 创建对象
            3. 调用类的类方法或访问类的类变量
            4. 派生子类
            
        定义类的语法:
            [修饰符] class 类名
            {
                成员变量 (field)
                方法(method)
                构造器(constructor)
                内部类(nested class)
                初始化模块
            }
            
            语法说明:
                1. 修饰符: 可以是 public, final | abstract("|"表示互斥), 或者完全可以省略, 
                2. 类名: 一个合法的标识符(字母,数字,下划线,$, 组成, 但是数字不能开头, 也不要用($)开头),
                        由有意义的单词组成, 每个单词首字母大写, 其他字母小写, 单词之间不要有分隔符
                3. 一个类最常见的成员: 构造器,成员变量,方法. 这三种都可以是零个或多个,如果零个,表示空类.
                4. static 修饰的成员不能访问没有 static 修饰的成员
                5. 花括号"{", "}" 之间的部分叫做" 类体 "
            
        成员变量(field):
            用于定义该类或该类的实例所包含的状态数据
            
            定义语法:
                [修饰符] 类型 成员变量名 [=默认值;]
            
            语法说明:
                1. 修饰符: private | protected | public, final, static, (transient: 序列化相关)
                2. 类型: 任意基本类型或者引用类型
                3. 变量名: 驼峰命名法, 首字母小写 后面每个单词首字母大写, 尽量使用与项目相关的描述性
                           的名词
                4. static修饰成员变量表明它属于这个类本身, 而不属于该类的单个实例, 所以static修饰的
                    变量叫做 类变量, 通常把不适用static修饰的成员变量也叫做实例变量, 实例方法.
                    
        方法(method):
            用于定义该类或该例的实例的行为特征或者功能实现,
            
            定义语法:
                [修饰符] 方法返回值类型 方法名(形参列表)
                {
                    // 代码: 由零条或者多条可执行语句组成的方法体
                    // 代码: 定义变量(包括数组), 变量赋值, 流程控制, 数据语句 

                    // 如果声明了返回值类型， 必须有return语句
                }
            
            语法说明:
                1. 修饰符:  private | protected | public, final | abstract, static, 
                2. 方法返回值类型: 可以是任意基本类型或引用类型, 可使用 void 声明没有返回值
                3. 方法名: 驼峰写法, 通常使用与项目相关的动词
                4. 形参列表: 定义该方法可以接受的参数, 可有零组或多组"参数类型 形参名" 组合而成, 多组
                             参数之间用(,) 隔开, 例如： 形参类型1 形参名1, 形参类型2 形参名2, ...
                5. 方法体中多条可执行语句之间有严格的执行顺序, 排在方法体前面的语句总是先执行, 排在
                    方法体后面的语句总是后执行
                6.  花括号"{", "}" 之间的部分叫做" 方法体 "
            
        构造器:
            构造器是一个类创建对象的根本途径, 如果一个类没有构造器, 这个类通常无法创建实例, new 调用
            构造器创建对象
            
            定义语法:
                [修饰符] 构造器名(形参列表)
                {
                    // 代码: 定义变量(包括数组), 变量赋值, 流程控制, 数据语句 
                }
            语法说明:
                1. 修饰符: private | protected | public 其中之一
                2. 构造器名: 构造器名必须和类名相同
                3. 和定义方法形参列表的格式完全相同
                4. 注意: 构造器既不能定义返回值类型, 也不能使用void声明构造器没有返回值
                5. 定义类的代码没有定义构造器, 系统将为它提供一个默认的构造器, 系统提供的构造器总是
                    没有参数的

        例子: 定义一个Person类
            public class Person
            {
                // 定义两个成员变量
                public String name;
                public int age;

                // 定义一个say方法
                public void say(String content)
                {
                    System.out.println(content);
                }
            }
        
        
    1.2 对象的产生和作用
        说明:
            创建对象的根本途径是构造器, 通过 new 关键字来调用某个类的构造器即可创建这个类的实例           
        
        Java对象的作用:
            1. 访问对象的实例变量
            2. 调用对象的方法           
        
        类或实例访问方法或成员变量的语法:
            1.  类.类变量|方法
            2.  实例.实例变量|方法
            3.  static 修饰的方法或成员变量, 既可通过类来调用, 也可通过实例来; 没有 static 修饰的
                普通方法和成员变量, 只能用过实例来调用
        
        例子:
            // 使用上面定义的 Person 类来定义一个 Person 类型的变量
            Person p;
            // 通过 new 关键字调用 Person 类的构造器, 返回一个 Person 实例
            // 将该 Person 实例赋给P变量
            p = new Person();
            
            // 上面你的代码也可以简化; 定义P变量的同时并为p变量赋值
            // Person p = new Person();
            // 访问p的name和age实例变量, 直接为该变量赋值
            p.name = "jefxff";
            p.age = 19;
            // 调用p的say()方法, 声明 say() 方法的时定义一个形参
            // 调用该方法必须为形参指定一个定义时声明类型的值
            p.Say("Java is so hard! But I can do it!")
            // 直接输出 p 的 name 实例变量
            System.out.println(p.name);


    1.3 对象, 引用和指针
        说明:
            1. 结合上面你的Java代码的例子,  代码: Person p = new Person(); 这行代码创建了一个 Person
               实例, 也被称之为Person对象;这行代码实际产生了两个东西:一个是p变量, 一个是Person对象. 
               这个Person对象被赋给p变量. 
               
            2. 类也是一种引用类型, 因此程序中定义的Person类型的变量实际上是一个引用, 他被存放在栈内
               存中, 指向实际的Person对象; 而真正的Person对象则存放在堆(heap)内存中. 
               
            3. 不管是数组还是对象,当程序访问引用变量的成员变量或方法时, 实际上是访问该引用变量所引用
               的数组, 对象的成员变量或方法.
               
            4. 栈内存里面的引用变量并未真正存储对象的成员变量, 对象的成员变量数据实际上存放在堆内存里,
               而引用变量只是指向该堆内存里面的对象.
               
            5. 所以, 引用变量与 C 语言里的指针很像, 他们都是存储一个地址值, 通过这个地址来引用到实际
               对象, 只是 Java 对这个指针进行了封装,
               
            6. 堆内存里的对象可以有多个引用, 即多个引用变量指向同一个对象, 代码: Person p2 = p; 这行 
               代码把p变量的值赋值给 p2 变量, 也就是将 p 变量保存的地址值赋给 p2 变量, 这样 p2 变量 
               和 p 变量将指向堆内存里的同一个 Person 对象,  所以不管访问 p 变量还是访问 p2 变量的
               成员变量和方法, 他们实际上是访问同一个 Person 对象的成员变量和方法, 将会返回相同的结果

    1.4 对象的 this 引用
        说明:
            1. this 关键字总是指向调用该方法的对象.根据this出现位置, 有2, 3两种情形
                出现在构造器中, this 就代表该构造器正在初始化的对象;
                出现在非static方法中, this就代表了该方法的拥有者;
            2. this关键字最大的作用就是让类中一个方法, 访问该类里的另一个方法或实例变量
            3. 谁在调用这个方法, this就代表谁
            4. this. 的很重要的作用是: 用于区分方法或构造器的局部变量. 尤其是与成员变量同名时--更需
                要this进行区分
            5. 如果在 static 修饰的方法中使用this关键字, 则这个关键字就无法指向合适的对象, 所以static 
                修饰的方法不能使用this引用. 因此 static 修饰的方法不能访问不使用static修饰的普通成
                员, 所以: 静态成员不能直接访问非静态成员.

        例子: 1. 没有使用this的情况下, 下面例子调用内部方法需要创建两个实例来实现
            public class Dog
            {
                // 定义一个jump 方法
                public void jump()
                {
                    System.out.println("正在执行 jump 方法.....");
                }
                // 定义一个 run() 方法, run()方法需要借助 jump() 方法
                public void run()
                {
                    Dog d = new Dog();
                    d.jump();
                    
                    System.out.println("正在执行 run 方法.....");
                }
                public static void main(String[] args)
                {
                    // 创建 dog 对象
                    Dog dog = new Dog();
                    // 调用 Dog 对象的 run() 方法
                    dog.run();
                }
            }
            
            说明: 1. 上面的程序中一共产生了Dog 对象, 调用run() 方法的是 dog , 而在 run() 方法中调
                        用jump() 方法的是 d 
                  2. 再记一遍, **没有 static** 修饰的成员变量和方法都必须使用**对象**来调用
                  3. static 修饰的方法属于类, 不属于对象
                
        例子: 2. 使用this方法, 代码同上面例子1, 但是只需要创建一个实例
            public class Dog
            {
                // 定义一个jump 方法
                public void jump()
                {
                    System.out.println("正在执行 jump 方法.....");
                }
                // 定义一个 run() 方法, run()方法需要借助 jump() 方法
                public void run()
                {
                    // 谁调用这个方法, this就代表谁
                    this.jump();
                    // 这是一种省略 this 的写法, 但是我属于刚开始, 就不要省略了
                    // jump();
                    
                    System.out.println("正在执行 run 方法.....");
                }
                public static void main(String[] args)
                {
                    // 创建 dog 对象
                    Dog dog = new Dog();
                    // 调用 Dog 对象的 run() 方法
                    dog.run();
                }
            }
        
        例子: 3. this 在构造器中, 代表构造器正在初始化的对象; 也可以区分成员变量和局部变量
        public class ThisInConstructor
        {
            // 定义一个名为foo的成员变量
            public int foo;
            
            // 定义构造器
            public ThisInConstructor()
            {
                // 在构造器里面定义一个和成员变量同名的 foo 变量
                int foo = 0;
                // 使用this代表该构造器正在初始化的对象
                // 下面的代码将会把该构造器正在初始化的对象的foo成员变量设为 6
                this.foo = 6;
                
            }
            public static void main(String[] args)
            {
                //所有使用 ThisInConstructor 创建的对象的foo 成员变量都将被设为6
                System.out.println(new ThisInConstructor().foo);   // out: 6
                
                // 创建对象, 使用对象输出 foo 
                ThisInConstructor t = new ThisInConstructor();
                System.out.println(t.foo);   // out: 6
            }
        }


2. 方法详解
    2.1 方法的所属性
        说明:
            1. 方法是类或者对象的行为特征的抽象, 方法是类或对象的最重要组成部分;
            
            2. Java里面的方法不能独立存在, 所有的方法都必须定义在类里面; 方法在逻辑上要么属于类, 要
                么属于该类的一个对象;
                
            3. Java中, 类是一等公民, 整个系统由一个一个的类组成, 一旦将一个方法定义在某个类体里面, 如
                果这个方法使用了static修饰, 则这个方法属于这个类, 否则这个方法属于这个类的实例;
                
            4. Java中执行方法时必须使用类或者对象来作为调用者, 即所有的方法都必须使用 "类.方法" 或者
                使用 "对象.方法" 的形式来调用;
                
            5. 同一个类的一个方法调用另外一个方法: 如果调用的是普通方法, 则默认使用 this 作为调用者, 
                如果被调用的方法是静态方法, 则默认使用 类 作为调用者. 
                
            6. 记住: 注意: 使用static修饰的方法既可以使用类作为调用者来调用, 也可以使用对象作为调用
                者来调用;  非 static 方法则属于该类的对象, 不属于类本身, 所以 非static方法只能使用对
                象来调用.
                
        例子:
            public class Dog
            {
                // 定义3个成员变量（实例变量）
                public String name = "旺财";
                public String color;
                public double weight;
                
                // 定义一个方法 （类方法）
                public void jump()
                {
                    System.out.println(this.name + " 正在执行 jump 方法.....");
                }
                // 定义一个run方法（类方法）
                public void run()
                {
                    // Dog d = new Dog();
                    // d.jump();
                    this.jump();
                    System.out.println("正在执行 run 方法.....");
                }
                // 定义一个 static 修饰的 barking 方法 （类方法）
                public static void barking()
                {
                    System.out.println("wangwangwang............");
                }
                // 程序的入口 main方法
                public static void main(String... args)
                {
                    Dog dog = new Dog();
                    // 实例调用非static修饰的方法
                    dog.run();
                    // 测试了, 现在再记住一次, 没有static修饰的方法, 只能用实例来调用, 下面用类 Dog 
                    // 调用没有static修饰的方法,  报错误:无法从静态上下文中引用非静态 方法 run()
                    // Dog.run();
                    System.out.println();
                    // 实例调用static修饰的方法
                    dog.barking();
                    // 类调用static修饰的方法
                    Dog.barking();
                    
                }
            }

    2.2 方法的参数传递机制
        参数传递方式:
            1. Java里方法的参数传递方式只有一种: 值传递. 值传递就是将实际参数值的副本(复制品)传入方
                法内,而参数本身不会受到任何影响;
                
            2. 值传递的实质: 当系统开始执行方法时,系统为形参执行初始化, 就是把实参变量的值赋给方法的
                形参变量, 方法里操作的并不是实际的实参变量.
                
        例子1: 基本类型的参数传递效果
            public class PrimitiveTransferTest
            {
                // 定义一个类方法，接受两个int类型的参数
                public static void swap(int a, int b)
                {
                    // 下面三行代码实现a, b 变量的值交换（python中： a, b = b, a 一句话就转换了）
                    // 定义一个临时变量来保存 a 变量的值
                    int tmp = a;
                    // 把 b 的值赋给 a
                    a = b;
                    // 把临时变量 tmp 的值赋给 b
                    b = tmp;
                    System.out.println("swap方法里交换后, a的值是: " + a + "; 变量b的值是: " + b );
                    
                }
                public static void main(String... args)
                {
                    int a = 6;
                    int b = 9;
                    swap(a, b);  // out: a = 9, b = 6
                    // 下面代码输出： a = 6, b =9
                    System.out.println("交换结束后: a的值是: " + a + "; 变量b的值是: " + b );
                    System.out.println();
                    
                    
                }
            }
        
            程序说明:
                程序的运行结果说明: swap()方法里 a和b 的值是 9和6, 交换结束后, 变量a和变量b的值依
                然是6和9. 说明mian方法里面的变量a和b, 并不是swap()方法里的a和b, swap()方法的a和b只
                是main()方法里变量a和b的复制品.
        
        例子2:引用类型的参数传递效果
            class DataWrap
            {
                int a;
                int b;
            }
            public class ReferenceTransferTest
            {
                public static void swap(DataWrap dw)
                {
                    // 下面三行代码实现 dw 的 a, b两个成员变量的值交换
                    // 定义一个临时变量来保存dw对象的a成员变量的值
                    int tmp = dw.a;
                    //把dw对象的b成员变量的值赋给a成员变量
                    dw.a = dw.b;
                    //把临时变量tmp的值赋给dw对象的b成员变量
                    dw.b = tmp;
                    System.out.println("swap方法里, a成员变量的值是: " + dw.a + 
                        "; b成员变量的值是: " + dw.b ); 
                }
                public static void main(String[] args)
                {
                    DataWrap dw = new DataWrap();
                    dw.a = 6;
                    dw.b = 9;
                    swap(dw);
                    System.out.println("交换结束后, a成员变量的值是: " + dw.a + 
                        "; b成员变量的值是: " + dw.b ); 
                }
            }

            程序说明:
                1.引用类型的参数传递还是值传递的方式, 系统一样复制了 dw 的副本传入 swap() 方法, 但
                  关键在于dw只是一个引用变量, 所以系统复制了 dw 的变量, 但并未复制DataWrap对象.
                2. 由于dw只是一个引用变量, 故实际操作的还是堆内存中的DataWrap对象.
                3. 在 swap方法中 将 dw 赋值为null 后, 不会影响main方法中dw变量操作.




    2.3 形参个数可变的方法
    
        传递类型:
            1. (类型... 形参名) 这种传递形参是个数可变的, 本质就是数组, 这种写法等同于下面的2类型
                如定义形参: public static void test(int a, String... books);
                  传递形参:test(6, "python", "java", "C", "JavaScript");
                  
            2. (类型[] 形参名) 
                如定义形参: public static void test(int a, String[] books); 
                  传递形参: test(6, new String[]{"python", "java", "C", "JavaScript"});

        传递类型说明:
            1. (类型... 形参名) 这种写法的好处是: 调用方法更加方便, 既可直接传入多个元素, 系统会自
                动将他们封装成数组, 也可以用数组; 缺点是: 这种写法只能作为形参列表的最后一个形参;
                [暗示]: 一个方法最多只能有一个"个数可变"的形参
                
            2. (类型[] 形参名) 这种写法的好处是: 这种数组形式的形参可以出现在形参列表的任意位置.

        例子1:形参个数可变的方法
            public class Varargs
            {
                //定义一个形参个数可变的方法
                public static void test(int a, String... books)
                {
                    //books 被当成数组处理, 使用foreach循环输出
                    for (String book : books)
                    {
                        System.out.println(book);
                    }
                    //输出a变量的值
                    System.out.println(a);
                }
                public static void main(String[] args)
                {
                    //直接用类调用static修饰的方法
                    test(6, "python", "java", "C", "JavaScript");
                    // 调用test的时候, 形参传入一个数组
                    test(6, new String[]{"python1", "java1", "C1", "JavaScript1"});
                }
            }

    2.4 递归方法
        说明: 
            1. 递归就是一个方法体内部调用它自身. 递归方法包含了一种隐式的循环, 他会重复执行某段代码,
                但这种重复执行无需循环控制, 但是还是要有让递归停止的条件, 并且这种条件存在, 否则就死
                循环了.
            2. 递归必须一定要向已知的方向递归.
            
        例子: 
            // 计算: 已知一个数列, f(0)=1, f(1)=4, f(n+2) = 2*f(n+1) + f(n); 求: f(10)的值
            public class recursive
            {
                public static int fn(int n)
                {
                    if (n == 0)
                    {
                        return 1;
                    }else if (n == 1)
                    {
                        return 4;
                    }else
                    {
                        return 2 * fn(n-1) + fn(n-2);
                    }
                }
                public static void main(String[] args)
                {
                    System.out.println(fn(10));
                }
            }
            
            程序说明:
                如上程序: 当一个方法不断地调用它本身的时候, 必须在某个时刻方法的返回值是确定的, 即不
                    再调用它本身, 否则这种递归就变成了无穷递归, 类似与死循环,
            
    2.5 方法重载
        说明: 
            Java允许同一个类里面定义多个同名方法,只要形参列表不同就行. 如果同一个类里面包含了多个方
            法名相同, 但形参列表的不的方法. 则被称之为方法重载
        
        注意:
            1. 调用者, 也就是方法的拥有者, 既可以是类, 也可以是对象
            2. 方法名, 方法的标识
            3. 形参列表, 当调用方法时, 系统将会根据传入的实参列表匹配
            4. 两同一不同: 同一个类中方法名相同, 参数列表不同; 其他的方法返回值类型, 修饰符等与方法
                重载无关.
            5. 尽量不要定义长度可变的形参列表
        
        例子: 方法的重载
            public class OverloadVarargs
            {
                public void test(String msg)
                {
                    System.out.println("只有一个字符串参数的test方法" + msg);
                }
                public void test(String name, String gender)
                {
                    System.out.println("形参长度为2的test方法" 
                    + name + gender);
                }
               
                // 因为前面已经定义了一个test()方法, test()方法里面有一个字符串参数
                // 此处的长度可变参数里不包含一个字符串参数的形式
                public static void (String... books)
                {
                    System.out.println("#-----形参长度可变的test方法-----#");
                }
                public static void main(String[] args)
                {
                    OverloadVarargs orl = new OverloadVarargs();
                    orl.test("注意看 ");
                    orl.test("水岛津实", "女");
                    orl.test(new String[]{"python1", "java1", "C1", "JavaScript1"});
                }
            }
        

3. 成员变量和局部变量
    3.1 成员变量和局部变量 
    
        成员变量: 
            含义: 
                成员变量指在类里面定义的变量,也就是前面学过的field(用于定义该类或该类的实例所包含的状态数据)

            包含: 
                实例变量 (不以static修饰)
                类变量 (以static修饰)
                
            访问语法:
                1. 类变量, 也就是类成员变量, 可通过类或者实例访问
                    类.类变量 
                    实例.类变量
                2. 实例变量, 也就是实例成员变量
                    实例.实例变量
                    
            说明:
                1.类变量:从该类的准备阶段起开始存在, 直到系统完全销毁这个类, 类变量的作用域与这个类
                   的生存范围相同
                2. 实例变量: 从该类的实例被创建起开始存在,直到系统完全销毁这个实例,实例变量的作用域
                   与对应实例的生存范围相同
                3. 命名规则: 多个有意义的单词连缀而成, 第一个单词首字母小写, 后面单词首字母大写
                4. 如果通过一个实例修改了类变量的值, 由于这个类变量不属于它, 而是属于它所对应的类,
                   因此修改的依然是该类的类变量, 与通过该类来修改类变量的结果完全相同, 这会导致该类
                   的其他实例来访问这个类变量时也将获得这个被修改过的值
            
            例子:
                class Person
                {
                    // 定义一个实例变量
                    public String name;
                    //定义一个类变量
                    public static int eyeNum;
                }
                public class PersonTest
                {
                    public static void main(String[] args)
                    {
                        // 第一次主动使用Person类,该类自动初始化, 则eyeNum变量开始作用,输出0
                        System.out.println("Person类的eyeNum类变量值:" + Person.eyeNum);
                        
                        // 创建Person对象
                        Person p = new Person();
                        // 通过Person对象的引用p访问Person对象name实例变量
                        // 并通过实例访问eyeNum类变量
                        System.out.println("p变量的name变量的值是: " + p.name 
                            + " p对象的eyeNum变量值是: " + p.eyeNum);
                        // 直接为 name 实例变量赋值
                        p.name = "孙悟空";
                        //通过p访问的eyeNum 类变量, 依然是访问Person的eyeNum类变量
                        p.eyeNum = 2;
                        
                        // 再次通过Person对象来访问name实例变量和eyeNum类变量
                        System.out.println("p变量的name变量的值是: " + p.name 
                            + " p对象的eyeNum变量值是: " + p.eyeNum);
                        
                        // 前面通过p修改了Person的eyeNum,此处的Person.eyeNum将输出2
                        System.out.println("Person类的eyeNum类变量值:" + Person.eyeNum);
                        
                        // 再创建一个实例对象
                        Person p2 = new Person();
                        // p2访问的eyeNum类变量依然引用Person类的, 因此输出2
                        System.out.println("p2对象的eyeNum类变量值: " + p2.eyeNum);
                    }
                }
                程序说明: 
                    1. 成员变量无需显示的初始化, 只要为一个类定义了类变量或者实例变量, 系统就会在这
                        个类的准备阶段或创建该类的实例时进行默认的赋值, 成员变量默认初始化时的赋值规
                        则与数组动态初始化时数组元素的赋值规则完全相同;
                    2. 类变量的作用域大于实例变量的作用域: 实例变量随实例的存在而存在, 而类变量则随
                        类的存在而存在. 实例也可以访问类变量, 同一个类的所有实例访问类变量时, 实际上 
                        访问的是该类本身的同一个变量, 也就是说, 访问了同一片内存.
       
            
        局部变量:
            含义: 
                局部变量就是指在方法里面定义的变量
                
            包含:
                形参 (方法签名中定义的变量): 作用域在整个方法体内有效
                方法局部变量 (在方法中定义): 作用域是从定义该变量的地方生效, 该该方法结束时失效
                代码块局部变量 (在代码块内定义): 作用域从定义该变量的地方生效, 到该代码块结束时失效
                
            说明:
                1. 局部变量除了形参之外(形参的初始化在调用该方法时由系统完成, 值由方法的调用者指定),
                    都必须显式的初始化; 也就是说, 必须先给方法局部变量和代码块局部变量指定初始值,
                    否则不可以访问它们.
                2. 方法的局部变量, 其作用域从定义该变量开始, 知道方法结束
                
            例子1:代码块局部变量例子
                public class BlockTest
                {
                    public static void main(String[] args)
                    {
                        // 代码块
                        {
                            // 定义一个代码块局部变量a
                            int a;
                            // 下面代码将出现错误, 因为a变量还未初始化
                            // BlockTest.java:10: 错误: 可能尚未初始化变量a
                            // System.out.println("代码块局部变量a的值: " + a);
                            // 为a 变量赋初始值, 也就是进行初始化
                            a = 5;
                            System.out.println("代码块局部变量a的值: " + a);
                        }
                        // 在代码块的外面访问a变量, 并不存在
                        // System.out.println( a);
                    }
                }
            
            例子2: 方法体内局部变量例子
                public class BlockTest
                {
                    public static void main(String[] args)
                    {                    
                        // 定义一个方法局部变量
                        int a ;
                        // 下面的代码是错误的, 因为a变量未初始化
                        // System.out.println("方法局部变量a的值: " + a);
                        // 为a 变量赋初始值, 也就是进行初始化
                        a = 5;
                        System.out.println("方法局部变量a的值: " + a);
                    }
                }

            注意: 
                1. 同一个类里面, 成员变量的作用范围是整个类里面有效
                2. 一个类里不能定义两个同名的成员变量, 即使一个是类变量, 一个是实例变量都不行
                3. 一个方法里不能定义两个同名的方法局部变量, 方法局部变量与形参也不能同名
                4. 同一个方法中不同代码块内的代码块局部变量可以同名; 
                5. 如果先定义代码块局部变量, 后定义方法局部变量, 前面定义的代码块局部变量与后面定义
                    的方法局部变量也可以同名
                6. Java 允许局部变量和成员变量同名, 如果方法里的局部变量和成员变量同名, 局部变量会
                    覆盖成员变量, 如果需要在这个方法里引用被覆盖的成员变量, 则可以使用this(对于实
                    例变量) 或类名(对于类变量)作为调用者来限定访问成员变量.
            
            例子3: 局部变量覆盖成员变量
                public class VariableOverrideTest
                {
                    // 定义一个 name 实例变量
                    public String name = "李刚";
                    // 定义一个price类变量
                    public static double price = 78.0;
                    // 主方法程序入口
                    public  static void main(String[] args)
                    {
                        // 方法里的局部变量, 局部变量覆盖成员变量
                        int price = 65;
                        // 直接访问 price 变量, 将输出 price　局部变量的值:65
                        System.out.println(price);
                        // 使用类名作为price变量的限定
                        // 将输出price类变量的值: 78.0
                        System.out.println(VariableOverrideTest.price);
                        
                        // 运行info 方法
                        new VariableOverrideTest().info();
                    }
                    public void info()
                    {
                        // 方法里的局部变量, 局部变量覆盖成员变量
                        String name = "孙悟空";
                        // 直接访问name变量, 将输出name局部变量的值: "孙悟空"
                        System.out.println(name);
                        // 使用this来作为name变量的限定
                        // 将输出name实例变量的值: "李刚"
                        System.out.println(this.name);
                    }
                    
                }

            
    3.2 成员变量的初始化和内存中的运行机制
        说明：
            1. 当系统加载类或创建该类的实例时，系统自动为成员变量分配内存空间，并在分配内存空间后,自
                动为成员变量指定初始值。
            2. (首次加载类时)在类的准备阶段，系统将为该类的类变量分配内存空间，并指定默认初始值
            3. 实例变量是在创建实例时分类内存空间并指定初始值
            4. 通过实例.类变量来访问类变量时，由于实例变量并没有保存类变量，所以还是访问的类的类变量;
                所以所有的实例访问类变量都是访问的类的类变量，即同一块内存区
            5. 所以由于上面4的原因，访问类变量时，尽量使用类作为主调


    3.3 局部变量的初始化和内存中的运行机制
        说明：
            1. 定义局部变量后，系统并未为这个变量分配内存地址，直到等到程序为这个变量赋初始值的时候
                系统才会为局部变量分配内存，并将初始值保存到这块内存中
            2. 局部变量不属于任何类或者实例，因此局部变量总是保存在其所在方法的栈内存中
            3. 若局部变量是基本类型的变量:则直接把这个变量的值保存在该变量对应的内存中
            4. 若局部变量是引用类型的变量:则这个变量里边存放的是地址，通过地址引用到改变了实际引用的
                对象或数组
            5. 局部变量所占的内存区通常比较小
            6. 栈内存中的变量无须系统回收，往往随方法或代码块的运行结束而结束 


    3.4 变量的使用规则
        原则：
            1. 能用局部变量就不用成员变量
            2. 使用局部变量也应该缩小局部变量的使用范围

        使用成员变量的场景：
            1. 若需要定义的变量是用于描述某个类或某个对象的固有信息
                如果：这种信息对这个类的所有实例完全相同，这种变量应定义为类变量
                如果：这种信息是实例相关的，这种变量应定义为实例变量 
            2. 如果在某个类中需要以一个变量来保存该类或者实例运行时的状态信息，这种用于保存某个类或
                某个实例状态信息的变量通常应该使用成员变量
            3. 如果某个信息需要在某个类的多个方法之间进行共享，则这个信息应该使用成员变量来保存

        扩大变量的作用域的缺点：
            1. 增大了变量的生存时间，导致更大的内存开销
            2. 扩大了变量的作用域，不利于提高程序的内聚性

        




































































































            