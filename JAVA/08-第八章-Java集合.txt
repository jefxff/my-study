1. Java集合概述
    说明: 
        1. Java集合类是一种特别有用的工具类, 可用于存储数量不等的对象, 并可以实现常用数据结构, 如队列,栈;
            集合类都在 java.util 包下, Java5后, 在java.util.concurrent 包下提供支持线程的集合类
        2. Java集合还可用于保存具有映射关系的关联数组
        3. Java集合分四种: Set(无序, 不可重复的集合), List(有序的, 重复的集合), Map(代表具有映射关系的集
            合), Queue(代表一种队列集合实现)
        4. Java的集合类主要由两个接口派生而出: Collection 和 Map , 他们是Java集合框架的根接口, 这两个接口
            包含一些子接口和实现类; Set和List和Queue接口是Collection接口派生的子接口
        5. 所有的Map实现类用于保存具有映射关系的数据(也就是关联数组), Map的实现类保存的都是 key-value 对, 
            也就是由 key 和 value 两个值组成, key 不可以重复, 而 value 可以重复
        6. 集合和数组的区别: 数组元素既可以是基本类型的值, 也可以是对象(实际上保存的是对象的引用变量); 而集
            合只能保存对象(实际上只是保存的对象的引用变量--记住)
    
    四种集合最常用的实现类;
        HashSet, TreeSet, ArrayList, ArrayDeque, LinkedList, HashMap, treeMap

    访问集合的元素:
        1. List集合元素直接通过索引来访问; 因为List是有序的集合
        2. Map集合的元素通过每项元素的key来访问其value; 因为Map集合的key值是不可重复的
        3. Set集合中的元素只能根据元素本身来访问; 因为Set集合的元素无序可重复

2. Collection 和 Iterator 接口
    说明:
        1. 由于 Collection 接口是 Set, List, Queue接口的父接口, 所以 Collection 接口定义的方法可用于操作
            Set, List, Queue集合
        2. 记住: 集合就像容器, 实现生活中容器的功能, 可添加对象, 删除对象, 清空对象, 判断容器是否为空等, 集
            合类就为这些功能提供了对应的方法

    Collection 接口定义的方法:
        1. boolean add(Object o)
            说明: 该方法用于向集合里添加一个元素, 如果集合对象被添加操作改变了(也就是添加成功), 就返回true 
        2. boolean addAll(Collection c)
            说明: 该方法把集合c里所有的元素添加到指定的集合里, 如果集合对象被添加操作该变了, 就返回true
        3. void clear()
            说明: 清空集合里的所有元素, 将集合的长度变为0
        4. boolean contains(Object o)
            说明: 返回集合里是否包含指定元素
        5. boolean containsAll(Collection c)
            说明: 返回集合里是否包含集合c里的所有元素
        6. boolean isEmpty()
            说明: 返回集合是否为空, 当集合长度为0时, 返回true, 否则返回false
        7. Iterator iterator()
            说明: 返回一个 Iterator对象, 用于遍历集合里的元素
        8. boolean remove(Object o)
            说明: 删除集合中指定元素o, 当集合中包含了一个或多个元素o时, 该方法只删除第一个符合条件的元素, 该
                方法将返回true
        9. boolean removeAll(Collection c)
            说明: 从集合中删除集合c里包含的所有元素(相当于调用该方法的结合减集合c), 如果删除了一个或一个以上
                的元素, 则该方法返回true
        10. boolean retainAll(Collection c)
            说明: 从集合中删除集合c里不包含的元素(相当于把调用该方法的集合变成该集合和集合c的交集), 如果操作
                改变了调用方法的集合, 则该方法返回true
        11. int size()
            说明: 该方法返回集合里的元素个数
        12. Object[] toArray()
            说明: 该方法把集合转换成一个数数组, 所有的集合元素变成对应的数组元素

    例子:
        // CollectionTest.java
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.HashSet;

        public class CollectionTest{
            public static void main(String[] args) {
                Collection c = new ArrayList();
                // 添加元素
                c.add("孙悟空");
                // 虽然集合里不能放基本类型, 但Java支持自动装箱
                c.add(6);
                System.out.println("c集合的元素个数为: " + c.size());
                // 删除指定元素
                c.remove(6);
                System.out.println("c集合的元素个数为: " + c.size());
                // 判断是否包含指定的字符串
                System.out.println("c集合是否包含\"孙悟空\"字符串: " + c.contains("孙悟空"));
                c.add("轻量级 Java EE 企业级应用实战");
                System.out.println("c集合的元素: " + c);

                Collection books = new HashSet();
                books.add("轻量级 Java EE 企业级应用实战");
                books.add("疯狂 Java 讲义");
                System.out.println("c集合是否包含books集合? " + c.containsAll(books));
                // 用c集合减去books集合的元素
                c.removeAll(books);
                System.out.println("c集合的元素: " + c);
                // 删除c集合的所有元素
                c.clear();
                System.out.println("c集合的元素: " + c);
                // 控制books集合里只剩下c集合里也包含的元素
                books.retainAll(c);
                System.out.println("books集合的元素: " + books);
            }
        }
        程序说明:
            1. 程序未使用泛型来限制集合里元素的种类, 编译会报警告
            2. 所有的 Collection 实现类都重写了 toString() 方法, 该方法可以一次性地输出集合中的所有元素

2.1 使用 Lambda 表达式遍历集合
    说明:
        1. Java8 为 Iterable 接口新增了一个 forEach(Consumer action)默认方法, 该方法所需的参数的类型是一
            个函数式接口, 而 Iterable 接口是 Collection 接口的父接口, 因此 Collection 接口也可以直接调用
            该方法
        2. 当程序调用 Iterable 的 forEach(Consumer action) 遍历集合元素时, 程序会依次将集合元素传给 
            Consumer 的 accept(T t) 方法 (该接口中唯一的抽象方法). 正因为 Consumer 是函数式接口, 因此可以
            使用Lambda表达式来遍历集合元素
        
    例子:
        // CollectionEach.java 
        import java.util.Collection;
        import java.util.HashSet;

        public class CollectionEach {
            public static void main(String[] args) {
                // 创建一个集合
                Collection books = new HashSet();
                books.add("java Note");
                books.add("Python Note");
                books.add("JavaScript Note");
                books.add("Css Note");
                // 调用 forEach()方法遍历
                books.forEach(obj -> System.out.println("迭代集合元素:" + obj));
            }
        }

2.2 使用Java8增强的 Iterator 遍历集合元素
    说明:
        1. Iterator 主要用于遍历(即迭代访问) Collection 集合中的元素, Iterator 对象也被称之为迭代器; 而 
            Collection 系列集合, Map系列集合主要用于盛装其他对象
        2. Iterator 接口隐藏了各种 Collection 实现类的底层细节, 向应用程序提供了遍历 Collection 集合元素
            的统一编程接口
    
    Iterator 接口里定义的方法:(例子1)
        1. boolean hasNext()
            说明: 如果被迭代的集合元素还没有被遍历完, 则该方法返回true
        2. Object next()
            说明: 返回集合里的下一个元素
        3. void remove()
            说明: 删除集合里的下一个元素
        4. void forEachRemaining(Consumer action)
            说明: 这是Java8为 Iterator 新增的默认方法, 该方法可使用Lambda表达式来遍历集合元素

    例子1:
        import java.util.Collection;
        import java.util.HashSet;
        import java.util.Iterator;
        public class IteratorTest{
            public static void main(String[] args){
                 // 创建一个集合
                Collection books = new HashSet();
                books.add("java Note");
                books.add("Python Note");
                books.add("JavaScript Note");
                books.add("Css Note");
                // 获取books集合对应的迭代器
                Iterator it = books.iterator();
                while (it.hasNext()){
                    // it.next()方法返回的数据类型是Object类型, 因此需要强制类型转换
                    String book = (String)it.next();
                    if(book.equals("Python Note")){
                        // 从集合中删除上一次 next() 方法返回的元素
                        it.remove();
                        // books.remove(book);  // ②
                    }
                    book = "测试字符串";   // ①
                }
                // out: [java Note, JavaScript Note, Css Note]
                System.out.println(books);
            }
        }
        程序说明:
            1. Iterator 仅用于遍历集合. Iterator 本身并不提供盛装对象的能力, 如果需要创建 Iterator 对象
            (程序中的 it), 则必须有一个被迭代的集合(程序中的books), 没有集合的 Iterator 没有存在的价值
            2. Iterator必须依附与Collection对象, 若有一个Iterator对象, 则必然有一个与之关联的 Collection
                对象, Iterator 提供了两个方法来迭代访问 Collection 集合里的元素, 并可通过 remove() 方法来
                删除集合中上一次next()方法放回的集合元素
            3. ①处的代码并没有改变books集合中的元素, 当使用Iterator 对集合元素进行迭代时, Iterator 并不是
                把集合元素本身(集合元素时引用变量)传给了迭代变量, 而是把集合元素的值(引用变量指向的堆内存的
                值)传给了迭代变量, 所以修改迭代变量的值对集合元素本身没有影响
            4. 当使用 Iterator 迭代访问 Collection 集合元素时, Collection 集合里的元素不能被改变, 只有通
                过 Iterator 的 remove() 方法删除上一次 next() 方法返回的集合元素才可以, 否则将引发异常

2.3 使用Lambda表达式遍历Iterator
    说明:
        1. Java8 为Iterator新增的一个 forEachRemaining(Consumer action) 方法, Consumer参数是函数式接口,
        2. 当程序调用 Iterator 的 forEachRemaining(Consumer action)遍历集合元素时, 程序会依次将集合元素
            传给 Consumer 的 accept(T t)方法(该接口中唯一的抽象方法)
    例子:
        public class IterctorEach{
            public static void main(String[] args){
                // 创建一个集合
                Collection books = new HashSet();
                books.add("java Note");
                books.add("Python Note");
                books.add("JavaScript Note");
                books.add("Css Note");
                // 获取books集合对应的迭代器
                Iterator it = books.iterator()
                // 使用Lambda表达式(目标类型是Consumer)来遍历集合元素
                it.forEachRemaining(obj -> System.out.println("迭代集合元素: " + obj));
            }
        }

2.4 使用 foreach 循环遍历集合元素
    例子:
        public class foreachTest{
            public static void main(String[] args){
                // 创建一个集合
                Collection books = new HashSet();
                books.add("java Note");
                books.add("Python Note");
                books.add("JavaScript Note");
                books.add("Css Note");
                for(Object obj : books){
                    // 此处的book变量也不是集合元素本身
                    // 将Object类型的变量强转为String类型
                    String book = (String)obj;
                    System.out.println(book);
                    if(book.equals("Python Note")){
                        // 下面的代码引发异常
                        books.remove(book);   // ①
                    }
                }
                System.out.println(books);
            }
        }
        程序说明:
            1. foreach循环中的迭代变量也不是集合元素本身, 系统只是依次把集合元素的值赋给迭代变量. 因此在
                foreach循环中修改迭代变量的值也没有实际意义
            2. 当使用 foreach 循环迭代访问集合元素时, 该集合也不能被改变, 否则将引发异常, 如①处

2.5 使用 Java8 新增的 Predicate 操作集合
    说明:
        1. removeIf(Predicate filter) 方法支持批量删除符合 filter 条件的所有元素; Predicate 也是函数式
            接口, 也可以使用Lambda表达式作为参数
    
    例子:
        import java.util.Collection;
        import java.util.HashSet;
        import java.util.function.Predicate;

        public class PredicateTest {
            public static void main(String[] args) {
                // 创建一个集合
                Collection books = new HashSet();
                books.add("java Note");
                books.add("Python Note");
                books.add("JavaScript Note");
                books.add("Css Note");

                // 使用Lambda表达式(目标类型是Predicate)过滤集合
                books.removeIf(ele -> ((String)ele).length() > 12);
                System.out.println(books);   // out: [java Note, Python Note, Css Note]
                // 统计书名中包含"Python"子串的图书数量
                System.out.println(calAll(books, ele -> ((String)ele).contains("Python"))); //out: 1
                // 统计书名中包含"Css"子串的图书数量
                System.out.println(calAll(books, ele -> ((String)ele).contains("Css")));  // out: 1
                // 统计书名字符串长度大于10的图书数量
                System.out.println(calAll(books, ele -> ((String)ele).length() > 10));  // out: 1
            }

            public static int calAll(Collection books, Predicate p) {
                int total = 0;
                for (Object obj : books){
                    // 使用 Predicate 的 test() 方法判断该对象是否满足 Predicate 指定条件
                    if (p.test(obj)){
                        total ++;
                    }
                }
                return total;
            }
        }
        程序说明:
            1. 上述程序先定义了一个calAll()方法, 该方法将会使用 Predicate 判断每个集合元素是否符合特定条件
                该条件将通过 Predicate 参数动态传入, 上述四行输出行代码传入了四个Lambda表达式(目标类型都
                是Predicate), 这样 calAll()方法就只会统计满足Predicate条件的图书


2.6 使用java8新增的 Stream 操作集合
    说明:
        1. Java8 还新增了 Stream, IntStream, LongStream, DoubleStream 等流式API, 这些API代表多个支持串
            行和并行聚集操作的元素; Stream 是一个通用的流接口, 而IntStream, LongStream, DoubleStream则是
            代表元素类型为 int, long, double 的流
        2. Java8 还为上面的每个流API提供了对应的 Biulder, 如: Stream.Builder, IntStream.Builder, 
            LongStream.Builder, DoubleStream.Builder, 可通过这些Builder 来创建对应的流
        3. Java8 允许使用流失API来操作集合, Collection接口提供了一个 stream()默认方法, 该方法可返回该集合
        对应的流, 接下来可通过流式API来操作集合元素, Stream可对集合元素进行整机的聚集操作

    独立使用 Stream 的步骤:
        1. 使用 Stream 或 XxxStream 的 builder() 类方法创建该 Stream 对应的 Builder 
        2. 重复调用 Builder 的 add() 方法向该流中添加元素
        3. 调用 Builder 的 build()方法获取对应的 Stream 
        4. 调用 Stream 的聚集方法

    中间方法, 末端方法, 有状态方法, 短路方法:
        1. 中间方法: 中间操作允许流保持打开状态, 并允许直接调用后续方法. 下面程序中的map()方法
        2. 末端方法: 末端方法是对流的最终操作; 当某个Stream执行末端方法后, 该流将会被"消耗"且不可再用; 下面
            程序中的sum(), count(), average() 方法都是末端方法
        3. 有状态方法: 这种方法会给流增加一些新的属性, 比如元素的唯一性, 元素的最大数量, 保证元素以排序的方
            式被处理等, 有状态方法往往需要更大的性能开销
        4. 短路方法: 短路方法可以尽早结束对流的操作, 不必检查所有的元素

    Stream 常用的中间方法:
        1. filter(Predicate predicate) 
            说明: 过滤Stream 中不符合 predicate 的元素
        2. mapToXxx(ToXxxFunction mapper)
            说明: 使用 ToXxxFunction 对流中的元素执行一对一的转换, 该方法返回的新流中包含了 ToXxxFunction
                转换生成的所有元素
        3. peek(COnsumer action)
            说明: 依次对每个元素执行一些操作, 该方法返回的流与原有流包含相同的元素, 主要用于调试
        4. distinct()
            说明: 该方法用于排序流中所有重复的元素(判断元素重复的标准是使用equals()比较返回true), 这是一个
                有状态的方法
        5. sorted()
            说明: 用于保证流中的元素在后续的访问中 处于有序状态, 是一个有状态的方法
        6. limit(long maxSize)
            说明: 用于保证对该流的后续访问中最大允许访问的元素个数. 有状态的,短路方法
        
    Stream 常用的末端方法:
        1. forEach(Consumer action)
            说明: 遍历流中的元素, 对每个元素执行action
        2. toArray()
            说明: 将流中的所有元素转换为数组
        3. reduce()
            说明: 该方法有三个重载版本: 都用于通过某种操作来合并流中的元素
        4. min()
            说明: 返回流中所有元素的最小值
        5. max()
            说明: 返回流中所有元素的最大值
        6. count()
            说明: 返回流中所有元素的数量
        7. anyMatch(Prerdicate predicate)
            说明: 判断流中是否至少包含一个元素符合Predicate条件
        8. allMatch(Predicate predicate)
            说明: 判断流中是否每个元素都符合Predicate条件
        9. noneMatch(Predicate predicate)
            说明: 判断流中没有一个元素符合Predicate条件
        10. findFirst()
            说明: 返回流中的第一个元素
        11. findAny()
            说明: 返回流中的任意一个元素

    例子1:
        public class IntStreamTest{
            public static void main(String[] args){
                IntStream is = IntStream.builder()
                    .add(20)
                    .add(13)
                    .add(-2)
                    .add(18)
                    .build();

                // 下面调用聚集方法的代码每次执行执行一行
                System.out.println("is 所有元素的最大值: " + is.max().getAsInt());
                System.out.println("is 所有元素的最小值: " + is.min().getAsInt());
                System.out.println("is 所有元素的总和: " + is.sum());
                System.out.println("is 所有元素的总数: " + is.count());
                System.out.println("is 所有元素的平均值: " + is.average());
                System.out.println("is 所有元素的平方是否都大于20: " 
                    + is.allMatch(ele -> ele * ele > 20) );
                System.out.println("is 是否包含任何元素的平方大于20: " 
                    + is.anyMatch(ele -> ele * ele > 20) );
                // 将 is 映射成一个新的 Stream, 新的 Stream 的每个元素是原 Stream 元素的 2倍加1
                IntStream newIs = is.map(ele -> ele * 2 + 1);
                // 使用方法引用的方式来遍历集合元素 ============== 19/09/16 的晚上我已经忘了方法引用~~~
                newIs.forEach(System.out::println);  // out: 41 27 -3 37 
            }
        }
        
    例子2: 
        import java.util.Collection;
        import java.util.HashSet;

        public class CollectionStream {
            public static void main(String[] args) {
                // 创建一个集合
                Collection books = new HashSet();
                books.add("java Note");
                books.add("Python Note");
                books.add("JavaScript Note");
                books.add("Css Note");

                //统计书名包含 Note 子串的图书
                System.out.println(books.stream()
                    .filter(ele -> ((String)ele).contains("Note")).count());  // out: 4
                //统计书名包含 Java 子串的图书
                System.out.println(books.stream()
                    .filter(ele -> ((String)ele).contains("Java")).count());  // out: 1 
                // 统计书名字符串长度大于10的图书数量
                System.out.println(books.stream()
                    .filter(ele -> ((String)ele).length() > 10).count());  // out: 2
                // 先调用 Collection 对象的 stream()方法将集合转换为Stream
                // 在调用 Stream 的 mapToInt() 方法获取原有Stream对应的 IntStream
                books.stream().mapToInt(ele -> ((String)ele).length())
                    // 调用 forEach() 方法遍历 IntStream 中每个元素
                    .forEach(System.out::print);  // out: 9 15 11 8
            }
        }
        程序说明:
            1. 程序只要调用 Collection 的 stream() 方法即可返回该集合对应的Stream, 接下来就可以通过Stream
                提供的方法对所有的集合元素进行处理, 可以简化代码
            2. 上面程序最后一条输出语句, 先调用Collection 对象的 stream() 方法(即: books.stream())将集合
                转换为 Stream对象, 然后调用 Stream对象的mapToInt() 方法将其转换为 IntStream; 这个过程中
                mapToInt() 方法就是一个中间方法, 因此程序可以继续调用 IntStream 的 forEach 方法来遍历流
                中的元素


3. Set集合
    说明:
        1. Set集合不允许包含相同的元素, 如果试图把两个相同的元素加入同一个Set集合中, 则添加操作失败, add() 
            方法返回false, 且新元素不会被加入
        2. 着重学习Set接口的三个实现类: HashSet, TreeSet, EnumSet

3.1 HashSet 类 
    说明:
        1. HashSet是set接口的典型实现类, HashSet按Hash算法来存储集合中的元素
        2. 当向 HashSet 集合存一个元素时, Hashset 会调用该对象的 hashCode() 方法来获取该对象的HashCode值,
            然后根据该hashCode值决定该对象在 HashSet 中的存储位置
        3. 如果两个元素通过 equals()方法比较返回 true, 但他们的 hashCode()方法返回值不相等, HashSet 将会
            把他们存储在不同的位置, 依然可以添加成功; 即 HashSet 集合判断两个元素相等的标准是两个对象通过
            equals()方法比较相等, 并且两个对象的hashCode()方法的返回值也相等
            
    HashSet特点:
        1. HashSet 不能保证元素的排列顺序, 顺序可能与添加顺序不同, 顺序也有可能发生变化
        2. HashSet 不是同步的, 如果多个线程同时访问一个Hashset, 假设有两个或两个以上线程同时修改了 Hashset 
            集合时, 则必须通过代码来保证其同步
        3. HashSet 集合的元素可以是 null 
     
    例子:
        // 通过类A,B,C, 他们分别重写了equals(),hashCode()两个方法的一个或全部, 通过这个例子:理解HashSet
        //   集合判断两个元素相同的标准(equals()和hashCode()都相等)
        // 类 A 的equals()方法总是返回true, 没有重写hashCode()方法
        class A{
            public boolean equals(){
                return ture;
            }
        }
        // 类 B 的hashCode() 方法总是返回1, 但是没有重写euqals()方法
        class B {
            public int hashCode(){
                return 1;
            }
        }
        // 类 C 的 hashCode()方法总是返回2, 且equals()方法总是返回true
        class C {
            public boolean equals(){
                return true;
            }
            public int hashCode(){
                return 2;
            }
        }
        public class HashSetTest{
            public static void main(String[] args){
                HashSet books = new HashSet();
                // 分别向books添加两个A对象, 两个B对象, 两个C对象
                books.add(new A());
                books.add(new A());
                books.add(new B());
                books.add(new B());
                books.add(new C());
                books.add(new C());
                System.out.println(books);
            }
        }
        程序说明:
            1. 由于C类重写了equals()方法总是返回true, hashCode()方法总是返回2, 将导致HashSet把两个C对象
                当成同一个对象
            2. 即使连个A对象通过equals()方法返回true,但HashSet依然把他们当成两个对象, 即使两个B对象的
                hashCode返回相同值, 但HashSet依然把他们当成两个对象
            3. 注意: 如果两个对象通过equals()方法总是返回true,这两个对象的hashCode值也应该相等
            4. 类B的equals()返回true,但是hashCode不同;这将会导致HashSet会把两个对象保存在Hash表的不同位置
                从而是两个对象都可以添加成功, 这就与Set集合的规则起冲突了
            5. HashSet中每个能存储元素的"槽位"(slot)通常称为"桶"(bucket), 如果有多个元素的hashCode值相同
                但他们通过equals()方法比较返回false, 就需要在一个"桶"里放多个元素, 这样导致性能下降
            6. 如果向 HashSet 中添加一个可变对象后, 后面程序修改了该可变对象的实例变量, 则可能导致它与集合
                中的其他元素相同(即两个对象通过equals()方法比较返回true,两个对象的hashCode值也相等),这就
                有可能导致 HashSet 中包含两个相同的对象(下面例子1)

    重写hashCode()方法的基本规则:
        1. 在程序运行过程中, 同一个对象多次调用HashCode()方法应该返回相同的值
        2. 当两个对象通过equals()方法比较返回true时, 这两个对象的hashCode值也应该相等
        3. 对象中用作equals()方法比较标准的实例变量, 都应该用于计算hashCode值

    hashCode 值的计算方式:  
        实例变量类型                          计算方式
        boolean                             hashCode = (f?0:1);
        整数类型(byet,short,char,int)        hashCode = int(f);
        long                                hashCode = (int)(f^(f>>>32));
        float                               hashCode = Float.flaotToIntBits(f);
        double                              long i = Double.doubleToLongBits(f);
                                            hashCode = (int)(i^(i>>>32));
        引用类型                             hashCode = f.hashCode();

    重写hashCode()方法的步骤:
        1. 把对象内每个有意义的实例变量(即每个参与equals()方法比较标准的实例变量)计算出一个int类型的
            hashCode值
        2. 用第一步计算出的多个hashCode值组合计算出一个hashCode值返回, 为避免直接相加产生偶然相等,可以通过
            为各实例变量的hashCode值乘以任意一个质数后再相加,如:
            return f1.hashCode() * 19 + (int)f2 * 32;

    例子1:
        import java.util.HashSet;
        import java.util.Iterator;

        class R {
            int count;
            public R(int count){
                this.count = count;
            }
            public String toString(){
                return "R[count: " + count + " ]";
            }
            public boolean equals(Object obj){
                if(this == obj){
                    return true;
                }
                if(obj != null && obj.getClass() == R.class){
                    R r = (R)obj;
                    return this.count == r.count;
                }
                return false;
            }
            public int hashCode(){
                return this.count;
            }
        }
        public class HashSetTest2{
            public static void main(String[] args){
                HashSet hs = new HashSet();
                hs.add(new R(5));
                hs.add(new R(-3));
                hs.add(new R(9));
                hs.add(new R(-2));
                // 打印HashSet集合, 集合元素没有重复
                System.out.println(hs);
                // 取出第一个元素
                Iterator it = hs.iterator();
                R first = (R)it.next();
                // 为第一个元素count实例变量赋值
                first.count = -3;   // ①
                // 再次输出 HashSet 集合, 集合元素有重复元素
                System.out.println(hs);
                // 删除count为-3的R对象
                hs.remove(new R(-3));    // ②
                // 可以看到被删除了一个R元素
                System.out.println(hs);
                System.out.println("hs是否包含count为-3的R对象?"
                    + hs.contains(new R(-3))); // 输出 false 
                System.out.println("hs是否包含count为-2的R对象?"
                    + hs.contains(new R(-2))); // 输出 false
            }
        }
        程序说明:
            1. 当向HashSet中添加可变对象时, 如果修改HashSet集合中的对象, 有可能导致该对象与集合中的其他对象
                相等, 从而导致HashSet无法准确访问该对象

3.2 LinkedHashSet 类 
    说明:
        1. LinkedHashSet 集合也是根据元素的hashCode值来决定元素的存储位置, 但它同时使用链表维护元素的次序,
            这样使得元素看起来是以插入的顺序保存的; 即:当遍历 LinkedHashSet 集合里的元素时, LinkedHashSet
            将会按元素的添加顺序来访问集合里的元素(但它依然是HashSet,不允许集合元素重复)
        2. LinkedHashSet 需要维护元素的插入顺序, 因此性能略低于 HashSet 的性能, 但在迭代访问 Set 里的全部
            元素时将有很好的性能, 因此它以链表来维护内部顺序
        3. 一句话: LinkedHashSet 集合的元素,访问元素的顺序和添加元素的顺序一致
    
    例子:
        import java.util.LinkedHashSet;

        public class LinkedHashSetTest {
            public static void main(String[] args){
                LinkedHashSet books = new LinkedHashSet();
                books.add("python");
                books.add("Java");
                System.out.println(books);    // out: [python, Java]
                // 删除 python 
                books.remove("python");
                // 重新添加 python 
                books.add("python");
                System.out.println(books);    // out: [Java, python]
            }
        }


3.3 TreeSet 类
    说明:
        1. TreeSet是SortedSet接口的实现类, TreeSet可以确保集合元素处于排序状态
        2. TreeSet采用红黑树的数据结构来存储集合元素, TreeSet支持两种排序方式, 自然排序和定制排序,默认情况
            下,TreeSet采用自然排序
        3. 因为TreeSet中的元素是有序的, 所以增加了访问第一个, 前一个, 后一个, 最后一个元素的方法, 和三个从
            TreeSet中截取子TreeSet的方法
        4. TreeSet 并不是根据插入的元素顺序来进行排序, 而是根据元素实际值的大小来进行排序
    
    TreeSet 提供的方法:
        1. Comparator comparator()
            说明: 如果 TreeSet 采用了定制排序, 则该方法返回定制排序所使用的 Comparator; 如果 TreeSet 采用
                了自然排序, 则返回null
        2. Object first()
            说明: 返回集合中的第一个元素
        3. Object last()
            说明: 返回集合中的最后一个元素
        4. Object lower(Object e)
            说明: 返回集合中位于指定元素之前的元素(即小于指定元素的最大元素, 参考元素不需要是TreeSet集合里
                的元素)
        5. Object higher(Object e)
            说明: 返回集合中位于指定元素之后的元素(即大于指定元素的最小元素, 参考元素不需要是TreeSet集合里
                的元素)
        6. SortedSet subSet(Object fromElement, Object toElement)
            说明: 返回此Set的子集合,范围从fromElement(包含)到toElement(不包含)
        7. SortedSet headSet(Object toElement)
            说明: 返回此Set的子集, 由小于toElement的元素组成
        8. SortedSet tailSet(Object fromElement)
            说明: 返回此Set集合的子集, 由大于或等于fromElement的元素组成

    例子:
        // TreeSet 方法应用
        import java.util.TreeSet;

        public class TreeSetTest{
            public static void main(String[] args){
                TreeSet nums = new TreeSet();
                // 向nums添加四个Integer对象
                nums.add(5);
                nums.add(2);
                nums.add(10);
                nums.add(-9);
                // 输出集合元素看到集合元素已经排序
                System.out.println(nums);     // out: [-9, 2, 5, 10]
                // 输出集合里的第一个元素
                System.out.println(nums.first());     // out: -9
                // 输出集合里的最后一位元素
                System.out.println(nums.last());     // out: 10
                // 返回小于4的子集, 不包含4
                System.out.println(nums.headSet(4));     // out: [-9, 2]
                // 返回大于等于5的子集
                System.out.println(nums.tailSet(5));     // out: [5, 10]
                // 返回大于等于-3 小于4的子集
                System.out.println(nums.subSet(-3, 4));     // out: [2]
            }
        }

    自然排序:
        说明:
            1. 原理: treeSet调用集合元素的 compareTo(Object obj)方法来比较元素之间的大小关系, 然后将集合
                元素按升序排列, 这种方式就是自然排序
            2. 向TreeSet集合中添加元素时, 只有第一个元素无需实现Comparable接口, 后面添加的所有元素都必须实
                现Comparable接口; 但是这样的话, 当试图从TreeSet中取出元素时, 依然会引发ClassCastException
                异常(例子1)
            3. 所以注意: 大部分类在实现compareTo(Object obj)方法时, 都需要将被比较对象 obj 强制转换成相同
                的类型, 因为只有两个相同类的两个实例才会比较大小; 当试图把一个对象添加到TreeSet集合时, 
                TreeSet会调用该对象的 compareTo(Object obj)方法与集合中的其他元素进行比较, 这就要求集合中
                的其他元素与该元素是同一个类的实例, 也就是说, 向TreeSet中添加的应该是同一个类的对象, 否则会
                引发ClassCastException异常 (例子2)
            4. 总结: TreeSet正常运作的前提就是, TreeSet只能添加同一种类型的对象
            5. TreeSet集合判断两个对象是否相等的唯一标准是: 两个对象通过compareTo(Object obj)方法比较是否
                返回0; 返回0则相等,否则不相等
            6. 如果向TreeSet中添加了一个可变对象, 并且后面程序修改了该可变对象的实例变量, 这将导致它与其他
                对象的大小顺序发生了改变, 但TreeSet不会再次调整他们的顺序, 甚至可能导致TreeSet中保存的这两
                个对象通过compareTo(Object obj)方法比较返回0, (例子4)
            
        关于 Comparable接口:
            1. 该接口里定义了compareTo(Object obj)方法, 该方法返回一个整数值, 实现该接口的类必须是实现该
                方法, 实现了该接口的类的对象就可以比较大小
            2. 当一个对象调用该方法与另一个对象比价大小的时候, 例如 obj1.compareTo(obj2), 如果该方法返回0,
                则表明两个对象相等, 如果返回一个正整数, 则表明obj1大于obj2, 返回一个负整数, 则说明obj1小于
                obj2(例子3)

        Comparable接口的一些常用实现类:
            1. BigDecimal, BigInteger 以及所有的数值型对应的包装类: 
                说明: 按他们对应的数值大小进行比较
            2. Character 
                说明: 按字符的 UNICODE 值进行比较
            3. Boolean 
                说明: true对应的包装类实例大于false对应的包装类实例
            4. String 
                说明: 按字符串中字符的 UNICODE 值进行比较
            5. Date, Time
                说明: 后面的时间, 日期比前面的时间日期大

        例子1:
            // 试图将一个对象添加到TreeSet时, 没实现Comparable接口, 第二次添加时, 报错
            class Err{}
            public class TreeSetErrTest{
                public static void main(String[] args){
                    TreeSet ts = new TreeSet();
                    // 向TreeSet集合中添加两个Err对象
                    ts.add(new Err());
                    ts.add(new Err());  // 在第二次添加时会报错
                }
            }

        例子2:
            public class TreeSetErrTest2{
                public static void main(String[] args){
                    TreeSet ts = new TreeSet();
                    // 向TreeSet集合中添加两个Err对象
                    ts.add(new String("Python"));
                    ts.add(new Date());   // 这行代码引发异常, 因为两个对象是不同类型
                }
            }

        例子3:
            import java.util.TreeSet;

            // Z 类实现Comparable接口
            class Z implements Comparable{
                int age;
                //构造器
                public Z (int age){
                    this.age = age;
                }
                //重写equals()方法, 总是返回True
                public boolean equals(Object obj){
                    return true;
                }
                // 重写 compareTo(Object obj)方法, 总是返回1
                public int compareTo(Object obj){
                    return 1;
                }
            }
            public class TreeSetTest2{
                public static void main(String[] args){
                    TreeSet set = new TreeSet();
                    Z z1 = new Z(6);
                    set.add(z1);
                    // 第二次添加同一个对象, 输出true, 表明添加成功
                    System.out.println(set.add(z1));
                    // 下面输出set集合, 将输出两个元素
                    System.out.println(set);   // out: [chapter08.Z@2f333739, chapter08.Z@2f333739]
                    // 修改set集合的第一个元素的age变量
                    ((Z)(set.first())).age = 9;
                    // 输出set集合的最后一个元素的age变量,将看到也变成了9
                    System.out.println(((Z)(set.last())).age);    // out: 9
                }
            }
            程序说明:
                1. 注意: 如果两个对象通过equals()方法比较返回true时,这两个对象通过compareTo(Object obj)
                    方法比较应该返回0(返回0表示相等)

        例子4:
            // R 类实现Comparable接口
            class R implements Comparable{
                int count;
                //构造器
                puublic R(int count){
                    this.count = count;
                }
                public String toString(){
                    return "R[count: " + count + " ]";
                }
                // 重写equals()方法,通过count来判断是否相等
                public boolean equals(Object obj){
                    if (this == obj){
                        return true;
                    }
                    if (obj != null && obj.getClass() == R.class){
                        R r = (R)obj;
                        return r.count == this.count;
                    }
                    return false;
                }
                // 重写 compareTo(Object obj)方法, 根据count来比较大小
                public int compareTo(Object obj){
                    R r = (R)obj;
                    return count > r.count ? 1: count < r.count ? -1 : 0;
                }
            }
            public class TreeSetTest3{
                public static void main(String[] args){
                    TreeSet ts = new TreeSet();
                    ts.add(new R(5));
                    ts.add(new R(-3));
                    ts.add(new R(9));
                    ts.add(new R(-2));
                    // 打印TreeSet集合, 集合元素是有序排列的
                    System.out.println(ts);
                    // 取出第一个元素
                    R first = (R)ts.first();
                    // 对第一个元素的count赋值
                    first.count = 20;
                    // 取出最后一个元素
                    R  last = (R)ts.last();
                    // 对最后一个元素的count赋值, 与第二个元素的count相同
                    last.count = -2;
                    // 再次输出将看到 TreeSet 里的元素处于无序状态, 且由重复的元素
                    System.out.println(ts);
                    // 删除实例变量被改变的元素, 删除失败
                    System.out.println(ts.remove(new R(-2)));
                    System.out.println(ts);
                    // 删除实例变量没有被改变的元素, 删除成功
                    System.out.println(ts.remove(new R(5)));
                    System.out.println(ts);
                }    
            }
            程序说明:
                1. 与 HashSet 类似的是, TreeSet中包含可=可可变对象, 当可变对象的实例变量被修改时, TreeSet
                    在处理这些对象时非常复杂, 而且容易错, 
                2. 为了程序更加健壮, 尽量不要修改放入HashSet和TreeSet集合中元素的关键实例变量 

    定制排序:
        说明:
            1. 通过Comparator接口实现定制排序, 该接口包含一个 int compare(T o1, T o2)方法, 该方法用于比较
                o1和o2的大小: 如果该方法返回正整数, 则表明o1大于o2, 如果该方法返回0,则表明o1等于o2; 如果该
                方法返回负整数, 则表明o1小于o2
            2. 要实现定制排序, 则需要在创建TreeSet集合对象时, 提供一个 Comparable 对象与该 TreeSet集合关联
                由该 Comparable 对象负责集合元素的排序逻辑; 由于 Comparable 是一个函数式接口, 可使用Lambda
                表达式来代替Comparator对象(例子1)
            3. 当通过 Comparator 对象(或lambda表达式)来实现TreeSet的定制排序时, 依然不可以向TreeSet中添加
                类型不同的对象, 否则也会引发ClassCastExxeption异常
            4. 使用定制排序时, TreeSet对集合元素排序不管集合元素本身的大小, 而是由 Comparator对象(或lambda
                表达式)负责集合元素的排序规则. TreeSet判断两个集合元素相等的标准是: 通过 Comparator (或者
                Lambda表达式)比较两个元素返回了0, 这样TreeSet不会把第二个元素添加到集合中
            
        例子1:
            class M{
                int age;
                public M(int age){
                    this.age = age;
                }
                public String toString(){
                    return "M[age: " + age + " ]";
                }
            } 
            public class TreeSetTest4{
                 public static void main(String[] args){
                    // 此处 Lambda 表达式的目标类型是 Comparator
                    TreeSet ts = new TreeSet((o1, o2) -> {
                        M m1 = (M)o1;
                        M m2 = (M)o2;
                        // 根据M对象的 age 属性来决定大小, age 越大, M对象反而越小
                        return m1.age > m2.age ? -1 : m1.age < m2.age ? 1 : 0;
                    });
                    ts.add(new M(5));
                    ts.add(new M(-3));
                    ts.add(new M(9));
                    ts.add(new M(-10));
                    ts.add(new M(0));
                    // out: [M[age: 9 ], M[age: 5 ], M[age: 0 ], M[age: -3 ], M[age: -10 ]]
                    System.out.println(ts);
                 }    
            }
            程序说明:
                1. 上述例子中的Lambda表达式部分使用了目标类型为Comparator, 它负责ts集合的排序
                2. 当把M对象添加到ts集合中时, 无须M类实现Comparable接口, 因此此时TreeSet无须通过M对象本身
                    来比较大小, 而是由与TreeSet关联的Lambda表达式来负责集合元素的排序

3.4 EnumSet 类 
    说明:
        1. EnumSet是一个专为枚举类设计的集合类, EnumSet中所有元素都必须是指定枚举类型的枚举值, 该枚举类型在
            创建EnumSet时显式或隐式的指定
        2. EnumSet 的集合元素也是有序的, EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序
        3. EnumSet 在内部以位向量的形式存储, 这种存储形式非常紧凑, 高效, EnumSet对象占用内存很小, 而且运行
            效率很高; 尤其是进行批量操作(如调用containsAll()和retainAll()方法)时, 如果参数只是EnumSet集合,
            则该批量操作的执行速度也非常快
        4. EnumSet集合不允许加入null元素, 如果试图插入null元素, 则会报NullPointerException异常; 判断
            EnumSet是否包含null元素和试图删除null元素都不会抛出异常(删除操作返回false)
        5. EnumSet类没有提供构造器来创建该类的实例, 程序应该通过它提供的类方法来创建EnumSet对象
    
    EnumSet类创建EnumSet对象的方法:
        1. EnumSet allOf(Class elementType) 
            说明: 创建一个包含指定枚举类里所有枚举值的EnumSet集合
        2. EnumSet complementOf(EnumSet s)
            说明: 创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合, 新EnumSet集合包含原EnumSet集
                合所不包含的, 此枚举类剩下的枚举值(即新EnumSet集合和原EnumSet集合的集合元素加起来就是该枚举
                类的所有枚举值)
        3. EnumSet copyOf(Collection c)
            说明: 使用一个普通集合来创建EnumSet集合(当复制Collection集合中的所有元素来创建新的EnumSet集合时
                要求Collection集合中的所有元素必须是同一个枚举类的枚举值)(例子2)
        4. EnumSet copyOf(EnumSet s)
            说明: 创建一个与指定 EnumSet 具有相同元素类型, 相同集合元素的EnumSet集合
        5. EnumSet noneOf(class elementType)
            说明: 创建一个元素类型为指定枚举类型的空EnumSet
        6. EnumSet of(E first, E... rest)
            说明: 创建一个包含一个或多个枚举值的EnumSet集合, 传入的多个枚举值必须属于同一个枚举类
        7. EnumSet range(E from, E to)
            说明: 创建一个包含从 from 到 to 枚举值范围内所有枚举值的EnumSet集合 
        
    例子1:
        // 如何使用EnumSet来保存枚举类的多个枚举值
        import java.util.EnumSet;

        enum Season {
            SPRING, SUMMER, FALL, WINTER
        }
        public class EnumSetTest{
            public static void main(String[] args){
                // 创建一个EnumSet集合, 集合元素就是Season枚举类的全部枚举值
                EnumSet es1 = EnumSet.allOf(Season.class);
                System.out.println(es1); // 输出[SPRING, SUMMER, FALL, WINTER]
                // 创建一个EnumSet空集合, 指定其集合元素是Season类的枚举类
                EnumSet es2 = EnumSet.noneOf(Season.class);
                System.out.println(es2); // 输出[]
                // 手动添加两个元素
                es2.add(Season.WINTER);
                es2.add(Season.SPRING);
                System.out.println(es2); // 输出 [SPRING, WINTER]
                // 以指定枚举值创建EnumSet集合
                EnumSet es3 = EnumSet.of(Season.SUMMER, Season.WINTER);
                System.out.println(es3); // 输出[SUMMER, WINTER]
                EnumSet es4 = EnumSet.range(Season.SUMMER, Season.WINTER);
                System.out.println(es4); // 输出[SUMMER, FALL, WINTER]
                // 新创建的EnumSet集合元素和es4集合元素有相同的类型
                // es5集合元素 + es4集合元素 = Season雷剧类的全部枚举值
                EnumSet es5 = EnumSet.complementOf(es4);
                System.out.println(es5); // 输出[SPRING]
            }
        }
    
    例子2:
        public class EnumSetTest2{
            public static void main(String[] args){
                Collection c = new HashSet();
                // 清空集合元素
                c.clear();
                c.add(Season.FALL);
                c.add(Season.SPRING);
                // 复制Collection集合中的所有元素来创建EnumSet集合
                EnumSet es = EnumSet.copyOf(c);
                System.out.println(es); // 输出[SPRING, FALL]
                c.add("Python");
                c.add("Love Java");
                // 下面的代码出现异常: 因为c集合里的元素不是全部都为枚举值
                es = EnumSet.copyOf(c);
            }
        }
3.5 各 Set 实现类的性能分析
    1. HashSet 的性能总是比TreeSet好(特别是最常用的添加, 查询元素等操作), 因为TreeSet需要额外的红黑树算法来
        维护集合元素的次序
    2. 只有当需要一个保持排序的Set时, 才应该使用TreeSet, 否则都应该使用 HashSet
    3. LinkedHashSet 对于普通的插入, 删除操作, LinkedHashSet 比 HashSet 要略微慢一点, 这是由于维护链表所
        带来的额外开销造成的, 但由于链表, 遍历LinkedHashSet会更快
    4. EnumSet 是所有的Set实现类中性能最好的, 但它只能保存同一个枚举类的枚举值作为集合元素
    5. 注意: Set 的三个实现类 HashSet, TreeSet, EnumSet都是线程不安全的, 多线程的情况下需要在创建时通过
        Collections工具类的 SynchronizedSortedSet方法来"包装"该Set集合, 以防止对Set集合的意外非同步访问
        如: SortedSet s = Collections.SynchronizedSortedSet(new TreeSet(...));



4. List 集合
    说明: 
        1. List集合代表的一个元素有序, 可重复的集合, 契合中每个元素都有其对应的顺序索引
        2. List 集合允许使用重复元素, 可以通过索引来访问指定位置的集合元素, List集合默认按照元素的添加顺序
            设置元素的索引
        3. List集合可以使用普通的for循环来遍历集合元素
        4. List 集合判断两个对象相等只要通过equals方法比较返回true即可(例子2)

4.1 Java8改进的List接口和ListIterator接口(例子1)
    List根据索引来访问元素的方法:
        1. void add(int index, Object element)
            说明: 将元素element插入到List集合的index索引处
        2. boolean addAll(int index, Collection c)
            说明: 将集合c包含的所有元素都插入到List集合的index索引处
        3. Object get(int index)
            说明: 返回List集合index索引处的元素
        4. int indexOf(Object o)
            说明: 返回对象 o 在List集合中第一次出现的位置索引
        5. int lastIndexOf(object o)
            说明: 返回对象o在List集合中最后一次出现的位置索引
        6. Object remove(int index)
            说明: 删除并返回index索引处的元素
        7. Object set(int index, Object element)
            说明: 将index所引出的元素替换成element对象, 返回被替换的旧元素(使用该方法时, 指定的索引必须是
                List集合的有效索引; 该方法并不会改变List集合的长度)
        8. List subList(int fromIndex, int toIndex)
            说明: 返回从索引fromIndex(包含)到索引toIndex(不包含)处所有集合元素组成的子集合
        9. void replaceAll(UnaryOperator operator)
            说明: 根据operator指定的计算规则重新设置List集合的所有元素(例子3)
        10. void sort(Comparator c)
            说明: 根据Comparator参数对List集合的元素排序(例子3)

    例子1:
        import java.util.ArrayList;
        import java.util.List;

        // List集合根据索引来访问元素的方法
        public class LsitTest{
            public static void main(String[] args) {
                List books = new ArrayList();
                // 向books集合中添加三个元素
                books.add(new String("You Love Python"));
                books.add(new String("Yes I Love Java"));
                books.add(new String("Do U Want A Python Note"));
                System.out.println(books);
                // 将新字符串对象插入在第二个位置
                books.add(1, new String("Crazy Java Note"));
                for (int i = 0; i < books.size(); i++){
                    System.out.println(books.get(i));
                }
                // 删除第三个元素
                books.remove(2);
                System.out.println(books);
                // 判断指定元素在List集合中的位置
                System.out.println(books.indexOf(new String("Crazy Java Note")));
                // 将第二个元素替换成新的字符串对象
                books.set(1, new String("Hello world"));
                System.out.println(books);
                // 将books集合的第二个元素(包括)
                // 到第三个元素(不包括)截取成子集合
                System.out.println(books.subList(1, 2));
            }
        }
    例子2:
        import java.util.ArrayList;
        import java.util.List;

        class A {
            public boolean equals(Object obj){
                return true;
            }
        }
        public class ListTest2{
            public static void main(String[] args){
                List books = new ArrayList();
                // 向books集合中添加三个元素
                books.add(new String("You Love Python"));
                books.add(new String("Yes I Love Java"));
                books.add(new String("Do U Want A Python Note"));
                System.out.println(books);
                // 删除集合中的A对象, 将导致第一个元素被删除
                books.remove(new A());    // ①
                System.out.println(books);
                // 删除集合中的A对象, 再次删除集合中的第一个元素
                books.remove(new A());     // ② 
                System.out.println(books);
            }
        }
        程序说明:
            1. 执行①处的代码时, 程序试图删除一个A对象, List将会调用该A对象的equals()方法依次与该集合元素进
                行比较, 如果该equals()方法以某个集合元素作为参数时返回true, List将会删除该元素, A类重写了
                equals()方法, 该方法总是返回true, 所以每次从List集合中删除A对象时, 总是删除List集合中的第
                一个元素

    例子3:
        import java.util.ArrayList;
        import java.util.List;

        public class ListTest3 {
            public static void main(String[] args){
                List books = new ArrayList();
                // 向books集合中添加四个元素
                books.add(new String("Python"));
                books.add(new String("Java"));
                books.add(new String("JavaScript"));
                books.add(new String("Linux"));
                // 使用目标类型为comparator的Lambda表达式对List集合排序
                books.sort((o1, o2) -> ((String)o1).length() - ((String)o2).length());   // ①
                System.out.println(books);  // out: [Java, Linux, Python, JavaScript]
                // 使用目标类型为UnaryOperator的Lambda表达式来替换集合中所有元素
                // 该lambda表达式控制使用每个字符传的长度作为新的集合元素
                books.replaceAll(ele -> ((String)ele).length());    // ②
                System.out.println(books);  // out: [4, 5, 6, 10]
            }
            程序说明:
                1. ①处的代码控制对List集合进行排序, 传给sort()方法的Lambda表达式指定的排序规则是: 字符串长  
                    度越长, 字符串越大, 因此①处的代码执行完之后, List集合中的字符串会按由短到长的顺序排序
                2. ②处的代码传给replaceAll()方法的Lambda表达式指定了替换集合元素的规则: 直接用集合元素(字
                    符串)的长度作为新的集合元素.
    
    List集合的listIterator()方法:
        说明: 1. 该方法返回一个ListIterator对象, ListIterator接口继承了Iterator接口, 提供了专门的操作List
                的方法
            2. 使用 ListIterator 迭代List集合时, 开始也需要采用正向迭代, 即先使用next()方法进行迭代, 在迭
                代过程中可以使用add()方法向上一次迭代元素的后面添加一个新元素

        ListIterator接口在Iterotor接口基础上增加的方法:(例子1)
            1.  boolean hasPrevious()
                说明: 返回该迭代器关联的集合是否还有上一个元素
            2. Object previous()
                说明: 返回该迭代器的上一个元素
            3. void add(Object o)
                说明: 在指定位置插入一个元素

        ListIterator 和 Iterator 的区别:
            1. ListIterator增加了向前迭代的功能(Iterator只能向后迭代), 而且ListIterator还可通过add()方法
                向List集合中添加元素(Iterator只能删除元素)

        例子1:
            import java.util.ArrayList;
            import java.util.List;
            import java.util.ListIterator;

            public class ListIteratorTest {
                public static void main(String[] args){
                    String[] books = new String[]{
                        "Python", "Java", "JavScript", "Linux"
                    };
                    List bookList = new ArrayList();
                    for (int i = 0; i < books.length; i++){
                        bookList.add(books[i]);
                    }
                    ListIterator lit = bookList.listIterator();
                    while(lit.hasNext()){
                        System.out.println(lit.next());
                        lit.add("----------分隔符-----------");
                    }
                    System.out.println("======下面开始反向迭代======");
                    while(lit.hasPrevious()){
                        System.out.println(lit.previous());
                    }
                }
            }

4.2 ArrayList 和 Vector 实现类
    说明:
        1. ArrayList 和 Vector 是 List的实现类, 支持List接口的全部功能
        2. ArrayList 和 Vector 类都是基于数组实现的List类, 所以ArrayList 和 Vector类封装了一个动态的, 允
            许再分配的Object[] 数组
        3. ArrayList 或 Vector 对象使用 initialCapacity参数来设置该数组的长度, 当向ArrayList 或 Vector
            中添加大量元素时, 可使用 ensureCapacity(int minCapacity)方法一次性地增加 initialCapacity,
            这可以减少重分配的次数, 从而提高性能
        4. 如果知道 ArrayList 或 Vector 集合需要保存多少个元素, 则可以在创建他们时就指定 initialCapacity
            的大小; 如果创建空的 ArrayList 或 Vector 集合时不指定 initialCapacity参数, 则 Object[]数组的
            长度默认为10
        
    ArrayList 和 Vector 重分配 Object[]数组的方法:
        1. void ensureCapacity(int minCapacity)
            说明: 将 ArrayList 或 Vector 集合的 Object[] 数组长度增加大于或等于 minCapacity 值 
        2. void trimToSize()
            说明: 调整 ArrayList 或 Vector 集合的 Object[] 数组长度为当前元素的个数, 调用该方法可减少
                ArrayList 或 Vector 集合对象占用的存储空间

    ArrayList 和 Vector 的区别:
        1. ArrayList 是线程不安全的, 当多个线程访问同一个 ArrayList 集合时, 如果有超过一个线程修改了 
            ArrayList 集合, 则程序必须手动保证该集合的同步性;
        2. Vector 集合则是线程安全的, 无须程序保证集合的同步性; 因为 Vector 是线程安全的, 所以性能略低与
            ArrayList集合
        3. 不推荐使用 Vector 的实现类
    
