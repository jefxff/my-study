异常处理

1. 异常概述
    1. Java的异常机制主要依赖于 try, catch, finally, throw, throws 五个关键字, 其中 try 关键字后
      紧跟一个花括号括起来的的代码块, 简称 try块, 它里面放置可能引发异常的代码. catch 后对应异常类型
      和一个 代码块, 用于表明 catch 块用于处理这种类型的代码块; 多个 catch 块后还可以跟一个 finally 
      块, finally 块用于回收在 try 块里打开的物理资源, 异常机制会保证 finally 块总是被执行; throws
      关键字主要在方法签名中使用, 用于声明该方法可能抛出的异常, 而 throw 用于抛出一个实际的异常,
      throw 可以单独作为语句使用, 抛出一个具体的异常对象
    2. Java异常分为 Checked异常 和 Runtime异常; Checked异常 都是可以在编译阶段被处理的异常, 程序必须
      强制处理所有的 Checked异常, 而 RUntime异常则无需处理

2. 异常处理机制
    2.1 使用 try...catch 捕获异常
        1. Java的异常处理机制是, 当程序运行出现意外情形时, 系统会自动生成一个 Exception 对象来通知程序,
           从而实现 "业务功能实现代码" 和 "错误处理代码" 分离

        2. 语法格式
            try {
                // 业务实现代码
            }
            catch (Exception e){
                // 所有异常处理逻辑放在 catch 块中进行处理
            }

        3. 抛出异常
            如果执行 try 块里的业务逻辑 代码时出现了异常, 系统会自动生成一个异常对象, 该异常对象提交给
            Java运行时环境, 这个过程叫做 抛出(throw)异常

        4. 捕获异常
            当Java运行时环境收到异常对象时, 会寻找能处理该异常对象的 catch 块, 如果找到合适的 catch 块,
            则把该异常对象交给该catch块处理, 这个过程叫做捕获(catch)异常, 如果Java运行时环境找不到异常的
            catch块, 则运行时环境终止, Java程序也将退出
            先捕获小异常, 再捕获大异常

    2.2 异常类的继承体系
        1. Java的所有非正常情况分两种: 异常(Exception)和错误(Error), 他们都继承自 Throwable 父类
        2. Error错误, 一般是指与虚拟机相关的问题, 如果系统奔溃, 虚拟机错误, 动态链接失败, 这种错误无法恢复,
            且不可能捕获, 所以不能试图使用 catch 来捕获Error对象, 在定义方法时, 也无须在其 throws 子句中
            声明该方法可能抛出的 Error 及其任何子类
        3. Exception类对应的catch块应该排在其他所有catch块的后面, (原因是: Exception catch块如果排在第一位
            那么别的catch块就不会得到执行,因为所有的异常对象都是Exception或其子类的实例)
            且所有父类异常的catch块都应该排在子类异常catch块的后面(记: 先处理小异常, 再处理大异常)

        例子:
            // DivTest.java 
            public class DivTest{
                public static void main(String[] args) {
                    try {
                        int a = Integer.parseInt(args[0]);
                        int b = Integer.parseInt(args[1]);
                        int c = a / b;
                        System.out.println("输入两数相除的结果是: " + c);
                    }
                    catch (IndexOutOfBoundsException ie) {
                        System.out.println("数组越界: 运行程序时输入的参数个数不够");
                    }
                    catch (NumberFormatException ne) {
                        System.out.println("数字格式异常: 程序只能接收整数参数");
                    }
                    catch (ArithmeticicException ae) {
                        System.out.println("算术异常");
                    }
                    catch (Exception e) {
                        System.out.peintln("未知异常");
                    }
                }
            }

    2.3 Java7 提供的多异常捕获
        1. Java7之后, 每个catch块中可以捕获多种类型的异常
        2. 格式: catch 后的括号中多种异常类型之间使用竖线(|) 隔开
        2. 捕获多种类型的异常时, 异常变量有隐式的final修饰, 因此程序不能对异常变量重新赋值(但是捕获一种异常
            时, 异常变量并没有final修饰, 所以可以重新赋值)

        例子:
            // MultiExceptionTest.java 
            public class MultiExceptionTest {
                public static void main(String[] args) {
                    try{
                        int a = Integer.parseInt(args[0]);
                        int b = Integer.parseInt(args[1]);
                        int c = a / b;
                        System.out.println("输入两数相除的结果是: " + c);
                    }
                    catch(IndexOutOfBoundsException | NumberFormatException
                         | ArithmeticicException ie){
                        System.out.println("程序发生了数组越界, 数字格式异常, 算数异常之一的异常");
                        // 捕获多异常时, 异常变量默认有final修饰, 所以下面对 ie 赋值的代码错误
                        // ie = new ArithmeticicException("test");
                    }
                    catch(Exception e) {
                        System.out.println("未知异常");
                        // 捕获一种类型的异常时, 异常变量没有final 修饰, 所以下面对 e 变量赋值正确
                    }
                }
            }

    2.4 访问异常信息
        1. 通过访问 catch 块后的异常形参来获取异常对象的相关信息
        2. 当Java运行时决定调用某个catch块来处理该异常对象时, 会将异常对象赋给 catch 块后的异常参数, 程序
            通过该参数来获取异常的相关信息
        3. 异常对象的常用方法:
            getMessage(): 返回该异常的详细描述字符串
            printStackTrace(): 将该异常的跟踪栈信息输出到标准错误输出
            printStackTrace(PrintStream s): 将该异常的跟踪栈信息输出到指定输出流
            getStackTrace(): 返回该异常的跟踪栈信息
        
        例子:
            import java.io.FileInputStream;
            import java.io.IOException;

            public class AccessExceptionMsg {
                public static void main(String[] args) {
                    try {
                        FileInputStream fis = new FileInputStream("a.txt");
                    }
                    catch(IOException ioe) {
                        System.out.println(ioe.getMessage());
                        ioe.printStackTrace();
                    }
                }
            }
    
    2.5 使用 finally 回收资源
        1. finally块用于关闭在try中打开的物理资源(如:数据库连接, 网络连接, 磁盘文件), finally块总是被执行(
            除非在 try块 或 catch块 中掉用了 exit() 来退出虚拟机)
        2. Java的垃圾回收机制不会回收任何物理资源, 垃圾回收机制只能回收堆内存中对象所占用的内存
        3. 异常处理结构语法中只有 try块 是必需的, catch块 和 finally块 是可选的, 但 catch块和finally块至少
            出现其中之一, 也可以同时出现, 捕获父类异常的catch块必须位于捕获子类异常块的后面, 但不能只单独只有
            try块, 多个catch块必须位于try块的后面, finally块必须位于所有catch块的后面
        3. 语法格式:
            try{
                // 业务实现代码
            }
            catch(SubException e) {
                // 异常处理块1
            }
            catch(SubException2 e) {
                // 异常处理块2
            }
            finally {
                // 资源回收
            }

        例子:
            // FinallyTest.java
            import java.io.FileInputStream;
            import java.io.IOException;

            public class FinallyTest {
                public static void main(String[] args) {
                    FileInputStream fis = null;
                    try {
                        fis = new FileInputStream("a.txt");
                    }
                    catch(IOException ioe) {
                        System.out.println(ioe.getMessage());
                        // return 语句强制方法返回
                        return;
                        // 使用exit退出虚拟机
                        // System.exit(1);;
                    }
                    finally {
                        // 关闭磁盘文件, 回收资源
                        if (fis != null) {
                            try {
                                fis.close();
                            }
                            catch(IOException ioe) {
                                ioe.printStackTrace();
                            }
                        }
                        System.err.println("执行finally块回收资源!");
                    }
                }
            }